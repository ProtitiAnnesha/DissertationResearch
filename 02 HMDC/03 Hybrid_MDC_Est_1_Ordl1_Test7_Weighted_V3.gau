/*********NOTES FOR ME**********************/   
/*In this program, for the st. dev. of the betas the lower triangle of the cholesky decomposition is provided as a column vector,
The final st. error is also calculated for the cholesky decomposition of the variance covariance matrix

the number of cholesky factor estimated should be nmix*(nmix+1)/2, where nmix is the number of random parameters*/

/*For the variance covariance amtrix of the error term of the choice model, an upper triangle of the cholesky decomposition
of the error difference is provided - the number of elements estimated in for the cholesky decomposition of the error covariance 
is (nc-1)nc/2 if there is price variation where nc is the number of alternatives, 
if there is no price variation there will be the top left element needs to be fixed

Final standard errors are calculated for the cholesky factor*/

/*Written by Annesha January 2015
The MDCP model and a structural equation model that can handle both continuous and ordinal indicators
*/

new;
library maxlik;
maxset;

/*****************************************************************************
                  Global Variable Definitions
*****************************************************************************/
clearg __row,nobs,_config,_alp0to1,_price,_ranm, _randper, _randd, nc,datatset,_po,nvarm,nvardel,nvargam, post_obs;
clearg negative_infinity, positive_infinity, negative_infinity_d, positive_infinity_d, gradient_store, gradient_store1;
cls;

__row    = 3025;    // Number of rows to be read at a time by the log-likelihood function
nobs     = 3025;    // Number of observations in the dataset
_config  = 4;       // Utility specification configuration, possible values: 1, 4, 7 see the documentation for an explanation of each configuration
_alp0to1 = 1;       // 1 if you want the Alpha values to be constrained between 0 and 1, 0 otherwise
_price   = 0;       // 1 if there is price variation across goods, 0 otherwise
nc       = 6;       // Number of alternatives (in the universal choice set)
_cholk = 1;			//1 if the choice model error coefficients are estimated
nrep = 1; 			//Number of error repititions being used for the simulation study

/* Evaluation of the multivariate normal cumulative distribution function (cdf)
   To improve running times, it is recommended to use MACML for the estimation. Otherwise, the user can use the GAUSS function 
   cdfn to compute the cdf */
_macml   = 1;    	// 1 if using MACML to estimate the multivariate normal cdf, 0 if using the biult-in GAUSS function
_ranm    = 1;		// MACML variable: 1 if random coefficients in baseline preferences
_randper = 1;       // MACML variable: random permutations of all digits 
_randd   = 0;       // MACML variable: all permutations or random permutations
nvar_latent = 5;	//Total number of latent variables
nvar_mear_cont = 0; //Number of continuous indicators in the model
nvar_mear_ordl = 15; //Number of ordinal indicators in the model
nvar_mear = nvar_mear_cont + nvar_mear_ordl; 		//Number of measurement equations
seednext = 983654;  // MACML variable: seed to run MACML

//dataset  = "C://Users//ane13003//OneDrive - University of Connecticut//ResearchCoursesOther_UCONN//HMDC Code Revision//ATUSV3.dat"; // provide path for the gauss data matrix
dataset  = "C://Users//ane13003//OneDrive - University of Connecticut//ResearchCoursesOther_UCONN//HMDC Code Revision//ATUSV3_01.dat"; // provide path for the gauss data matrix
dataMat = loadd(dataset);

negative_infinity = -100;
positive_infinity = 100;
negative_infinity_d = 0;
positive_infinity_d = 0;
/*****************************************************************************
                    Variable Specification Area
*****************************************************************************/

{ unov,ivuno } = indices(dataset,"uno");


{ serov,ivsero } = indices(dataset,"zero");


{ weight,wtind } = indices(dataset,"uno");

/*Psotion of indicatos in the data set*/
{ ContIndi,ContInd } = indices(dataset,""); @Column munbers of the continuous indicators@ 

{ OrdIndi,OrdInd } = indices(dataset,"Hap1"|"Hap2"|"Hap3"|"Pain1"|"Pain2"|"Pain3"|"Sad1"|"Sad2"|"Sad3"|"Stress1"|"Stress2"|"Stress3"|"Tired1"|"Tired2"|"Tired3"); @Location of the ordinal indicators in the data file@

/* Positions of the DEPENDENT Variables (i.e., the consumption quantities for each alternative - NOT consumption expenditures for each alternative).  
   Provide labels (one label in each double-quote) of the dependent variables (i.e., consumption quantities) in your dataset. 
   Number of labels = number of alternatives. */
{ choicm,f } = indices(dataset,"ActLes"|"PasLes"|"PhyAct"|"ShNnMan"|"SprtArt"|"Social"); 

/* Positions of PRICE variables
   Provide labels of price variables (one label in each double-quote). Number of labels = number of alternatives.
   Provide all UNO variables if there is no price variation */
{ cprice,fp } = indices(dataset,"uno"|"uno"|"uno"|"uno"|"uno"|"uno");

/* Definition of INDEPENDENT variables */

/* Structural Equation Specification */
let ivl1 = { FemDum 	zero	zero 	zero 	zero 	zero 	zero 	zero  		zero 	zero 	zero 		zero 	zero 	zero  		zero 	AgeDum4	AgeCDum2  	zero 		zero 		zero 		zero 	zero 		zero 		zero 	zero 		zero 	zero 	zero 		EduDum3 	EduDum4  zero 	 zero  	 zero 	zero 	 Prtner1 zero  		zero  	 zero     helOne helTwo  	zero 	zero 	zero 	zero 	zero 	zero 	zero 	zero 	lifeOne  lifeTwo  zero     zero     zero      zero  	zero    zero     zero    zero };
let ivl2 = { zero 		FemDum  zero	zero	zero	midInc	highInc	VhighInc	zero	zero 	zero 		zero 	zero 	zero 		zero 	zero 	zero 		AgeDum3		AgeDum4  	AgeCDum2 	zero 	zero 		zero 		zero 	zero 		zero 	zero 	zero 		zero 		zero     EduDum4 zero  	 zero  	zero 	 zero 	 Prtner1  	zero  	 zero     zero   zero   	helOne 	helTwo 	zero 	zero 	zero 	zero 	zero 	zero 	zero   	 zero     lifeOne  lifeTwo  zero      zero 		zero    zero     zero    zero  };
let ivl3 = { zero 		zero	FemDum	zero 	zero 	zero	zero	zero		midInc	highInc	VhighInc 	zero 	zero 	zero 		zero 	zero 	zero 		zero 		zero 		zero 		AgeDum3	AgeDum4  	AgeCDum2 	zero 	zero 		zero 	zero 	zero 		zero 		zero     zero 	 zero 	 zero 	zero 	 zero 	 zero 		Prtner1  zero     zero   zero 		zero 	zero 	helOne 	helTwo 	zero 	zero 	zero 	zero 	zero  	 zero     zero     zero     lifeOne   lifeTwo   zero    zero     zero    zero  };
let ivl4 = { zero 		zero 	zero 	FemDum 	zero 	zero	zero	zero		zero	zero	zero 		midInc	highInc	VhighInc 	zero 	zero 	zero 		zero 		zero 		zero 		zero 	zero 		zero 		AgeDum4 AgeCDum2	zero 	zero 	zero 		zero 		zero     zero 	 EduDum2 EduDum3 EduDum4 zero 	 zero 		zero 	 zero     zero 	 zero  		zero 	zero 	zero 	zero 	helOne 	helTwo 	zero 	zero 	zero  	 zero  	  zero     zero     zero      zero  	lifeOne lifeTwo  zero    zero  };
let ivl5 = { zero 		zero 	zero 	zero 	FemDum  zero	zero	zero		zero	zero	zero 		zero 	zero 	zero 		midInc	zero 	zero 		zero 		zero 		zero 		zero 	zero 		zero 		zero 	zero 		AgeDum3	AgeDum4 AgeCDum2 	zero 		zero     zero 	 zero 	 zero  	zero  	 zero    zero  		zero     UnEmpDum zero   zero  		zero 	zero 	zero 	zero 	zero 	zero 	helOne 	helTwo  zero     zero     zero     zero     zero      zero   	zero    zero  	 lifeOne lifeTwo  };


{ p1,ivlt1 } = indices(dataset,ivl1');
{ p2,ivlt2 } = indices(dataset,ivl2');
{ p3,ivlt3 } = indices(dataset,ivl3');
{ p4,ivlt4 } = indices(dataset,ivl4');
{ p5,ivlt5 } = indices(dataset,ivl5');


/* In the following specification, ivm1, ivm2, ivm3 contain independent variable specifications (on right hand side) for baseline utility (PSI) for alternatives 1, 2 and 3
   Add a row for ivm4 below if there is a 4th alternative, another addiitonal row for ivm5 if there is a 5th alternative, ...  (number of rows = number of alternatives);
   Number of columns = Number of variables including alternative specific constants; consider first alternative as base  */
let	ivm1	=	{	uno 	zero 	zero 	zero 	zero	FemDum	zero  	zero 	 zero 	    AgeCDum1 	AgeCDum2 	zero  		zero  		zero  		zero 	zero 	zero  	zero 	 zero  	  zero  	highInc   VhighInc   zero  		zero 	 	zero 		zero   zero   		zero   		zero  		hhchild1    zero  		zero  		zero      zero     saturday      zero 	 	zero  	  zero  	zero  	  grpProb    zero    zero  	 zero  	zero   };
let	ivm2	=	{	zero 	zero 	zero 	zero 	zero 	zero	zero  	zero 	 zero 		zero 		zero 		zero  		zero  		zero  		zero 	zero 	zero  	zero 	 zero 	  zero  	zero    	zero     zero   	zero  		zero		zero   zero   		zero   		zero    	zero     	 zero  		zero     	zero      zero  	 zero  	     zero  	  	zero      zero       zero  	  zero  	zero     zero    zero  zero };
let	ivm3	=	{	zero 	uno 	zero 	zero 	zero 	zero	zero  	zero 	 zero 		zero 		zero 		AgeCDum1 	AgeCDum2  	zero  		stdnt 	EmpDum  zero  	zero 	 zero     zero  	zero 		zero   	 highInc   	VhighInc  	zero		zero   zero   		zero   		zero    	zero  	  	 zero  		zero     	zero      zero   	 zero  	     saturday  	zero  	  zero      zero       zero  	grpProb zero     zero 	 zero };
let	ivm4	=	{	zero  	zero 	uno 	zero 	zero 	zero	FemDum  zero 	 zero 		zero 		zero 		zero  		zero  		zero  		zero 	zero 	EmpDum  zero 	 zero     metroN    zero    	zero     zero   	zero  		VhighInc	zero   zero   		zero   		zero    	zero        hhchild1   hhchild3  	zero      zero   	 zero        zero  		saturday  zero      zero       zero  	zero  	grpProb  zero    zero  };
let	ivm5	=	{	zero 	zero 	zero 	uno 	zero 	zero	zero  	FemDum 	 zero 		zero 		zero 		zero  		zero  		AgeCDum1 	zero 	zero 	zero  	EmpDum   zero     zero  	zero    	zero     zero 		zero 		zero		midInc VhighInc   	zero   		Prtner1 	zero        zero   		zero      	hhchild1  zero   	 zero        zero  		zero  	  saturday  zero       zero  	zero  	zero     grpProb zero  };
let	ivm6	=	{	zero 	zero 	zero 	zero 	uno 	zero	zero  	zero 	 FemDum 	zero 		zero 		zero  		zero  		zero  		zero	zero	zero 	zero  	 EmpDum   zero  	zero    	zero     zero   	zero    	zero		zero   zero   		VhighInc    zero    	zero        zero   		zero      	zero      hhchild3   zero        zero  		zero      zero      saturday   zero  	zero  	zero     zero    grpProb  };


//Add a row for v4 below if there is a 4th alternative, another additional row for v5 if there is a 5th alternative,.... (number of rows = number of alternatives)
{ v1,ivmt1 }   = indices(dataset,ivm1');
{ v2,ivmt2 }   = indices(dataset,ivm2');
{ v3,ivmt3 }   = indices(dataset,ivm3');
{ v4,ivmt4 }   = indices(dataset,ivm4');
{ v5,ivmt5 }   = indices(dataset,ivm5');
{ v6,ivmt6 }   = indices(dataset,ivm6');

/* Define labels of the parameters in the baseline utility for output printing;
   Provide as many parameter labels as the number of columns in ivm1 (i.e., the number of variables in the Psi function) */
varnam =  "const1"|"const3"|"const4"|"const5"|"const6"|"Fem1"|"Fem4"|"Fem5"|"Fem6"|"AgeY1"|"AgeO1"|"AgeY3"|"AgeO3"|"AgeY5"|
"Student3"|"Emp3"|"Emp4"|"Emp5"|"Emp6"|"NMetro4"|
"hInc1"|"vhiInc1"|"hInc3"|"vhiInc3"|"vhiInc4"|"midInc5"|"vhiInc5"|"vhiInc6"|
"Prtner5"|
"child11"|"child14"|"child34"|"child25"|"child36"|
"Sat1"|"Sat3"|"Sat4"|"Sat5"|"Sat6"|"Prob1"|"Prob3"|"Prob4"|"Prob5"|"Prob6";
										
/* In the following specification, ivd1, ivd2, ivd3 contain input data specifications (on right hand side) for satiation parameters (Alphas) for alternatives 1, 2 and 3
   Add a row below for ivd4 if there is a 4th alternative, another additional row for ivd5 if there is a 5th alternative,.... (number of rows = number of alternatives)
   Number of columns = Number of alternatives.
   Note that you can also add individual-specific variables below, so that satiation varies across individuals; However, you will then have to translate outputs to compute actual alpha parameters.
   This code is written to provide you with the alpha parameters directly for the case when there is no variation in alpha across individuals */
let	ivd1	=	{	uno 	zero	zero	zero	zero 	zero 	};
let	ivd2	=	{	zero	uno 	zero	zero	zero 	zero 	};
let	ivd3	=	{	zero	zero	uno 	zero	zero 	zero 	};
let	ivd4	=	{	zero	zero	zero	uno	    zero 	zero 	};
let	ivd5	=	{	zero	zero	zero	zero	uno	 	zero    };
let	ivd6	=	{	zero	zero	zero	zero	zero	uno    };


/*Alpha = 1-exp(Delta) if Alpha < 1
Alpha = 1-(1/(1+exp(Delta))) if 0 < Alpha < 1   */

//Add a row for w4 below if there is a 4th alternative,..... (number of rows = number of alternatives)
{ w1,ivdt1 }   = indices(dataset,ivd1');
{ w2,ivdt2 }   = indices(dataset,ivd2');
{ w3,ivdt3 }   = indices(dataset,ivd3');
{ w4,ivdt4 }   = indices(dataset,ivd4');
{ w5,ivdt5 }   = indices(dataset,ivd5');
{ w6,ivdt6 }   = indices(dataset,ivd6');


let	ivg1	=	{	uno 	zero	zero	zero	zero 	zero 	FemDum 	zero	zero	zero	AgeCDum1 	zero 		zero    	zero   	  highInc   VhighInc    zero  	zero  	 zero  		zero  	zero };
let	ivg2	=	{	zero	uno 	zero	zero	zero    zero 	zero 	zero	zero	zero	zero 		zero 		zero 		zero  	  zero   	zero  		midInc  highInc  VhighInc  	zero  	zero } ;
let	ivg3	=	{	zero	zero	uno 	zero	zero 	zero 	zero 	FemDum	zero	zero	zero 		zero 		zero    	zero  	  zero 		zero		zero   	zero  	 zero  		midInc  zero };
let	ivg4	=	{	zero	zero	zero	uno	    zero 	zero 	zero 	zero	FemDum	zero	zero 		AgeCDum1 	zero    	zero  	  zero   	zero 		zero 	zero	 zero  		zero    VhighInc };
let	ivg5	=	{	zero	zero	zero	zero	uno	 	zero 	zero 	zero	zero	zero	zero 		zero 		zero    	zero  	  zero   	zero 		zero   	zero  	 zero 		zero  	zero };
let	ivg6	=	{	zero	zero	zero	zero	zero	uno 	zero 	zero	zero	FemDum	zero 		zero 		AgeCDum1    AgeCDum2  zero   	zero 		zero   	zero  	 zero  		zero  	zero };


{ u1,ivgt1 }   = indices(dataset,ivg1');
{ u2,ivgt2 }   = indices(dataset,ivg2');
{ u3,ivgt3 }   = indices(dataset,ivg3');
{ u4,ivgt4 }   = indices(dataset,ivg4');
{ u5,ivgt5 }   = indices(dataset,ivg5');
{ u6,ivgt6 }   = indices(dataset,ivg6');


ivl = ivlt1'~ivlt2'~ivlt3'~ivlt4'~ivlt5';			//A row containing the name of the data columns going into the structural equation of the latent variable
ivgenyc = ContInd';     //A row containing the names of the continuous indicators
ivgenyo = OrdInd';		//A row containing the column number sof ordinal indicators
ivm = ivmt1'~ivmt2'~ivmt3'~ivmt4'~ivmt5'~ivmt6'; // can append more: e.g. ~ivmt4'~ivmt5' and so on, based on the number of alternatives
ivd = ivdt1'~ivdt2'~ivdt3'~ivdt4'~ivdt5'~ivdt6'; // can append more: e.g. ~ivdt4'~ivdt5' and so on, based on the number of alternatives
ivg = ivgt1'~ivgt2'~ivgt3'~ivgt4'~ivgt5'~ivgt6'; // can append more: e.g. ~ivgt4'~ivgt5' and so on, based on the number of alternatives

nvarml = cols(ivl1);	//Number of parameters in the structural equation of the latent variable
nvarm = cols(ivm1);     // number of variables in baseline utility   = number of columns in ivm1, do not modify this
nvardel = cols(ivd1);   // number of variables in satiation          = number of columns in ivd1, do not modify this
nvargam = cols(ivg1);   // number of variables in translation        = number of columns in ivg1, do not modify this

// Associating columns with variable names
flagchm = f';

// Availability of alternatives
{avbl1,avb1indx} = indices(dataset,"uno");
{avbl2,avb2indx} = indices(dataset,"uno");
{avbl3,avb3indx} = indices(dataset,"uno");
{avbl4,avb4indx} = indices(dataset,"uno");
{avbl5,avb5indx} = indices(dataset,"uno");
{avbl6,avb6indx} = indices(dataset,"uno");


flagavm = avb1indx ~ avb2indx ~ avb3indx ~ avb4indx ~ avb5indx~avb6indx;  // can append more: e.g. ~avb4indx ~avb5indx and so on, based on the number of alternatives
flagprcm = fp';

/******************************************************************************
             Covariance Matrix
******************************************************************************/
/* The code computes the elements of the cholesky decomposition of the difference of error terms 
(see discussion on Page 12 of Bhat et al., 2012) */
 nCholOmega1 = (nvar_mear*(nvar_mear+1))/2; 		@Calculates how many parameters in the lower trig mat. of Ch. Fac. of psi@
 nCholOmega = (nvar_latent*(nvar_latent+1))/2; 	@Calculates how many parameters in the lower trig mat. of Ch. Fac. of Latent variable@
 ncov = nc*(nc+1)/2;			// Number of elements of the covariance matrix

/******************************************************************************
                          Starting values
******************************************************************************/
 Alpha = 0.1752|	0.0819|	0.0776|	0.2591|	0.3256| @Female Dummies@
	-0.2318|	-0.181|	-0.2855|	-0.2117|	-0.1769|	-0.2037|	-0.1266|	-0.1455|	-0.1643|	-0.0738| @Income dummies@
	0.1302|	0.22|	0.2737|	0.4189|	0.3756|	0.1883|	0.2203|	0.173|	-0.2851|	-0.3921|	-0.0927|	-0.2442|	-0.443| @Age Dummies@
	-0.2035|	-0.4338|	-0.1116|	0.1266|	0.2117|	0.3419| @Education indicators@
	0.2112|	-0.0613|	-0.1395|@Spouse indicator@
	-0.2004|@UnEmployment dummy@
	0.6761|	0.4756|	-1.5195|	-1.0868|	-1.0167|	-0.7817|	-0.8889|	-0.6892|	-1.0393|	-0.7895| @health problem indicator Indicator@
	-1.2577|	-0.6469|	0.6298|	0.2595|	1.2651|	0.4905|	1.2447|	0.5316|	0.962|	0.3195; @life quality indicator@
 
 Beta_corr = { 1	-0.1423		-0.413		-0.5235		-0.2658,
			-0.1423	0.999953	0.381049	0.5591		0.456509,
			-0.413	0.381049	1.0001		0.951646	0.455901,
			-0.5235	0.5591		0.951646	0.999983	0.58022,
			-0.2658	0.456509	0.455901	0.58022		1 }; @The covariance matrix of the latent variable@

 Beta_corr1_pass = (chol(Beta_corr))'; 	@chol() returns the upper triangle of Chl. decom. of Beta_corr with bottom of the matrix filled with zero@
 Beta_corr1_pass1 = Beta_corr1_pass;			@Upmat takes the upper triangle and transpose is to make it a lower triangular matrix@

 Beta_corr_active = { 	0 	1 	1  1 	1,
						1	0 	1  1	1,
						1	1	0  1	1,
						1   1   1  0    1,
						1	1 	1  1	0 };  	
 
 @This matrix makes the non-diagonal elements of the cholesky decomposed matrix to be sqrt((a^2)/(1-a^2))@
 @Or in other words the cholesky factor would be: sqrt(x^2/(1+x^2))@
 @CHANGED TO THE RECENT VERSION@
 for i(2,rows(Beta_corr),1);
	for j(1,i,1);
		if (i ne j AND Beta_corr_active[i,j]);
			temp = sumc(Beta_corr1_pass1[i,1:i-1]'.*Beta_corr1_pass1[i,1:i-1]');
			Beta_corr1_pass[i,j] = Beta_corr1_pass1[i,j]/sqrt(1-temp);
		endif;
	endfor;
 endfor;

 Chol_Corr_Map = {	1	0  0	0	0,	@Correlation of latent variable@
					2	3  0	0	0,
					4	5	6	0	0,
					7	8	9	10	0,
					11	12	13	14	15 }; 
  
  delta = 4.1301|	3.9918|	3.9825|	2.2396|	2.2789|	2.2377|	1.1979|	1.1703|	1.139|	1.7212|	1.6421|	1.5033|	2.7917|	3.0345|	3.4088; @Constants in the measurement equations of the latent variable@ @Number = number of indicators@	  
  
  d_matrix = 0.8976|	0|	0|	0|	0|
			1.0443|	0|	0|	0|	0|
			1.0301|	0|	0|	0|	0|
			0|	1.2135|	0|	0|	0|
			0|	1.3051|	0|	0|	0|
			0|	1.2245|	0|	0|	0|
			0|	0|	0.8683|	0|	0|
			0|	0|	0.8806|	0|	0|
			0|	0|	0.8508|	0|	0|
			0|	0|	0|	1.0924|	0|
			0|	0|	0|	1.1527|	0|
			0|	0|	0|	1.0362|	0|
			0|	0|	0|	0|	1.2029|
			0|	0|	0|	0|	1.4855|
			0|	0|	0|	0|	1.2986;
			
  @Note: The _max_active for d_matrix is set in a way so that, the factor loading is estimated only when the initial parameter value is greater than zero@
  Psi   = eye(nvar_mear);
  Psi   = (chol(Psi))'; 		@Psi must be a diagonal matrix with the diagonal element corresponding to the ordinal indicator fixed to 1@	

  /*****Veector of structural equation model parameters******/
  bb2 = Alpha|vech(Beta_corr1_pass)|delta|d_matrix|vech(Psi);@Beta_corr1_pass and Psi must be lower triangular matrix@
  if(nvar_mear_ordl > 0);
	  threshold_low = zeros(nvar_mear_ordl,1);
	  threshold_upper = 1.5*ones(nvar_mear_ordl,1);
	  bb2 = bb2|threshold_low|threshold_upper;
  endif;
  
  /******Active parameter setting for structural equation model**********/
 @If initial value of the factor loading is greater than zero, that factor loading will be active@
 //D_matrix_active1 = zeros(nvar_mear*nvar_latent,1);
 D_matrix_active = (d_matrix .> 0).*0;
 	
 Psi_active1    = zeros(nvar_mear,nvar_mear);
 PsiDiagAct = {};
 if(nvar_mear_cont > 0);
	 PsiDiagAct = PsiDiagAct|zeros(nvar_mear_cont,1);
 endif;
 if(nvar_mear_ordl > 0);
	 PsiDiagAct =  PsiDiagAct|zeros(nvar_mear_ordl,1);
 endif;
 Psi_active = vech(diagrv(Psi_active1,PsiDiagAct));
 //Psi_active     = vech(eye(nvar_mear_cont))); @Only the variances of the error in the measurement equation is estimated, if the indicator is continuous@	
				
 _max_active = zeros(nvarml,1)| 			@First block is for the parameters going into the structural eq. of lt. var.@
			   vech(Beta_corr_active)|					@This block is for the error correlation of the latent variable@
			   zeros(nvar_mear,1)|		@For means of the measurement equation@
			   D_matrix_active|			@For factor loadings, already defined previously@
			   Psi_active;				@For measurement equation error correlation, already defined previously@
 if (nvar_mear_ordl > 0);
	 _max_active = _max_active|zeros(nvar_mear_ordl,1)|ones(nvar_mear_ordl,1);
 endif;
/* Below is the code for defining EQMATDEL and EQMATGAM matrices; 
   These definitions correspond to restricted estimations of the alpha and gamma parameters across alternatives based on the configuration specified (see documentation) */
 if _config==1; //Estimates alpha parameters, gamma parameters are fixed to one
   EQMATDEL = eye(nvardel);
   EQMATGAM = ones(1,nc);
   Lambda = 0|0.0|
			1|1.5|	
			1|1.5|
			1|1.5|
			1|1.5; @Coefficient of the latent into the baseline utility@
   
   LambdaAct = 0|0|
			   1|1|	
			   1|1|
			   1|1|
			   1|1;
   bb = 0.5|-1.0|1.0|-1.0|-0.5;@nvarm@
   bb = bb|Lambda; @concatenating lambda@
   bb = bb|2.005945|	1.215149|	-1.407263|	2.11806|	1.399598|	1.913189|zeros(rows(eqmatgam),1); @concatenating alpha@
   _max_active = _max_active|ones(nvarm,1)|LambdaAct|zeros(rows(eqmatdel),1)|ones(rows(eqmatgam),1);
   //_max_active = _max_active|zeros(nvarm,1)|LambdaAct|zeros(rows(eqmatdel),1)|zeros(rows(eqmatgam),1);
 elseif _config==4; //Estimates gamma parameters, alpha paramters are fixed to zero
   EQMATDEL = ones(1,nc);
   EQMATGAM = eye(nvargam);
   Lambda = -0.0553|	-0.0617|	-0.0719|	0.1042|	-0.062|
			0|	0|	0|	0|	0|
			0.1206|	-0.0816|	0.0152|	0.045|	0.0344|
			0.0047|	-0.0285|	-0.2616|	0.3489|	-0.1014|
			0.127|	-0.1211|	-0.2304|	0.3428|	-0.0164|
			0.1|	-0.0461|	-0.1064|	0.2052|	-0.0324; @Coefficient of the latent into the baseline utility@
   
   LambdaAct = 	1.0|1.0|1.0|1.0|1.0|
				0.0|0.0|0.0|0.0|0.0|
				1.0|1.0|1.0|1.0|1.0|
				1.0|1.0|1.0|1.0|1.0|
				1.0|1.0|1.0|1.0|1.0|
				1.0|1.0|1.0|1.0|1.0; 
				
   bb = -1.3982|	-1.8928|	-1.8365|	-2.7911|	-1.1808|@Constants@
		0.3482|	0.2196|	0.1649|	0.3633| @Female Dummy@
		0.1414|	0.2897|	0.1097|	-0.1643|	0.172|	@AgeDummy@
		0.284| @Student dummy@
		0.0949|	0.232|	0.2368|	0.1252|@Employed dummy@
		-0.156|	@Not metropolitan dummy@
		0.174|	0.4003|	0.1619|	0.4404|	0.1984|	0.1121|	0.3306|	0.0884|@Income dummies@
		0.1367| @Presence of partner dummy@
		0.2332|	0.0806|	0.1331|	-0.2674|	0.0908|@Age of youngest hh child dummy@
		0.0674|	0.1057|	0.263|	0.3241|	0.0535|@Saturday indicator@
		-0.1516|	-0.4122|	-0.4241|	-0.2501|	-0.3047|@Physical problem indicator@
		Lambda|-1000*ones(rows(EQMATDEL),1)|
		5.1127|	5.2547|	5.4617|	4.4021|	7.6058|	5.3356|@Gamma constants@
		-0.1815|	-0.4968|	0.2196|	-0.1942|@Gender dummies@
		0.2379|	0.1693|	0.2798|	-0.3583|@Age dummeis@
		-0.1942|	-0.388|	-0.2631|	-0.1997|	-0.2989|	0.3001|	0.144 @Income dummies@;
		
   _max_active = _max_active|ones(nvarm,1)|LambdaAct|zeros(rows(eqmatdel),1)|ones(rows(eqmatgam),1);
 elseif _config==7;
   EQMATDEL = ones(1,nc);
   EQMATGAM = eye(nc);
   Lambda = zeros(nc*nvar_latent,1);
   LambdaAct = 1|1|0|1|1|1|
			   1|1|0|1|1|1;
   bb = -2.9882|	-1.9595|	-3.3865|	-2.9406|	-2.9755|-0.1616|	-0.0064|	0.1014|	-0.2786|	-0.249;@nvarm@
   bb = bb|Lambda; @concatenating lambda@
   bb = bb|-1000*ones(rows(EQMATDEL),1)|zeros(rows(EQMATGAM),1);
   _max_active = _max_active|ones(nvarm,1)|LambdaAct|zeros(rows(eqmatdel),1)|zeros(rows(eqmatgam),1);
 endif;

bcov0 =  { 1.0 		0.0   	0.0  	0.0   	0.0  	0.0,
		   0.0  	0.7358   0.0  	0.0   	0.0  	0.0,
		   0.192  	0.0   	0.910  	0.0   	0.0  	0.0,
		   0.0  	0.0   	0.0  	0.929   0.0  	0.0,
		   0.153  	0.0   	0.0  	0.0   	0.5368  0.0,
		   0.1432  	0.0   	0.0  	0.0   	0.0  	0.714 }; 

bcov = vech(upmat(bcov0)'); @lower triangular cholesky factor of the nc by nc error variacne covariance matrix@
	
//You can estimate the variance-covariance matrix of the error difference
//Even for that you have to fix the top left element if there is no price variation
if _cholk == 1;
  if _price == 1;
    _max_cov = { 1.00 0.00 0.00 0.00,
				 0.00 1.00 0.00 0.00,
				 0.00 0.00 1.00 1.00,
				 0.00 0.00 1.00 1.00 };  
  else;	
	_max_cov = 0|
			   0|0|
			   1|0|1|
			   0|0|0|1|
			   1|0|0|0|1|
			   1|0|0|0|0|1;
  endif; 
else;
  _max_cov = zeros(ncov,1);  
endif;	

//The serial of the coefficients, the mean beta, then the alpha parameters, then the gamma parameters
//Followed by the st.dev. of the betas, then the cholesky factor of the error term,
b = bb2|bb|bcov;			// You can also provide your own starting values
_max_active = _max_active|_max_cov;

/* Defining variable labels in satiation and translation parameter terms, random coefficients, and coraviance parameters for output printing */
Alpha_nam         =  0 $+ "Alpha" $+ ftocv(seqa(1,1,nvarml),2,0);
Beta_corr_nam     =  0 $+ "Tild" $+ ftocv(seqa(1,1,nCholOmega),2,0);
delta_nam         =  0 $+ "Delta" $+ ftocv(seqa(1,1,nvar_mear),2,0);
d_matrix_nam      =  0 $+ "D_caP" $+ ftocv(seqa(1,1,nvar_latent*nvar_mear),2,0);
Psi_nam           =  0 $+ "Psi" $+ ftocv(seqa(1,1,nCholOmega1),2,0);
varLmbda = 0 $+ "Lambda" $+ ftocv(seqa(1,1,nc*nvar_latent),2,0);
varndell = 0 $+ "D" $+ ftocv(seqa(1,1,rows(eqmatdel)),2,0);
varngam  = 0 $+ "G" $+ ftocv(seqa(1,1,rows(eqmatgam)),2,0);
varcov   = 0 $+ "chol"   $+ ftocv(seqa(1,1,ncov),2,0);
if (nvar_mear_ordl > 0);
	low_threshold_nam =  0 $+ "Low_th" $+ ftocv(seqa(1,1,nvar_mear_ordl),2,0);
	up_threshold_nam =  0 $+ "Up_th" $+ ftocv(seqa(1,1,nvar_mear_ordl),2,0);
endif;

/******************************************************************************
Other Maxlik globals */
if(nvar_mear_ordl == 0);
	_max_ParNames = Alpha_nam|Beta_corr_nam|delta_nam|d_matrix_nam|Psi_nam|varnam|varLmbda|varndell|varngam|varcov;     // Appending all the parameter (or coefficient) names            
elseif(nvar_mear_ordl>0);
	_max_ParNames = Alpha_nam|Beta_corr_nam|delta_nam|d_matrix_nam|Psi_nam|low_threshold_nam|up_threshold_nam|varnam|varLmbda|varndell|varngam|varcov;     // Appending all the parameter (or coefficient) names            
endif;
_max_Options = { bfgs stepbt };
_max_gradTol = 5e-5; 
//_max_GradCheckTol = 1e-6;


 final_result = {};
 count = 1;
 
 //for r(1,nrep,1); 
	//for j(1,10,1); 
		//seednext = 983654+j-1;  // MACML variable: seed to run MACML
		dataset1 = dataMat[.,.];
		nobs = rows(dataset1);	
		//m_one = sumc((dataMat[.,flagchm] .>0)');
		//print "rows(m_one) cols(m_one) how many ones: " rows(m_one) cols(m_one) sumc(m_one .== 1) sumc((m_one .!= 1).and(m_one .!= nc)) sumc(m_one .== nc);
 		//dataset1 = selif(dataMat[.,.], ((m_one.==1)));  print " rows and cols of dataset1: " rows(dataset1) cols(dataset1);
		//print "i = " i "w1 = " meanc(dataset1[.,3]) "w2 = " meanc(dataset1[.,4]);
		//call lprnorm(b,dataset1);
		_max_Maxiters = 100000;
		_max_GradProc = &lgdnorm;
		_max_CovPar = 3;        										 // modify according to the type of standard errors you need	
		//{ x,f,g,cov,retcode } = maxprt(maxlik(dataset1,0,&lprnorm,b));
		
		print meanc(lgdnorm(b,dataset1));
		
		//print meanc(lprnorm(b,dataset1));
		//print "b: " b[nvarml+1:nvarml+nCholOmega]';
		//print meanc(lprnorm(b,dataset1));
		/*Beta_corr1       = (upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])))';
		Beta_corr2       = Beta_corr1; @Beta_corr1 and Beta_corr2 are lower triangular matrices@
		for m(2,rows(Beta_corr1),1);
			for n(1,m,1);
				if (m ne n AND Beta_corr_active[m,n]);
					Beta_corr1[m,n] = Beta_corr2[m,n]/sqrt(1+Beta_corr2[m,n]^2); @Its just getting back the elements of the lower triangle of the cholesky decomposed matrix@
				endif;
				
				if (m eq n);
					temp = sumc(Beta_corr2[m,1:m-1]'.*Beta_corr2[m,1:m-1]');
					Beta_corr1[m,n] = 1/sqrt(1+temp);
					clear temp;
				endif;
			endfor;
		endfor;
		Beta_corr1 = Beta_corr1*Beta_corr1';

		bb1 = x[1:nvarml];
		bb1 = bb1|vech(chol(Beta_corr1)')|x[nvarml+ncholOmega+1:rows(x)];*/
		
		
		//alpha1 = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)];
		
		/*if _alp0to1;
			alpha0 = 1/(1+exp(-alpha1)); //alpha0 is alpha
		else;
			alpha0 = 1 - exp(alpha1);// alpha0 is alpha
		endif;
		gamma1 = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)]; 
		gamma0 = exp(gamma1);*/
		//bb1 = bb1|alpha1|gamma1|x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)];
	    //clear _max_CovPar;
		//_max_Maxiters = 0;
		//_max_GradProc = &lgdnorm1;
		//_max_CovPar = 1;
		//_max_GradCheckTol = 1e-6;
		
		//{ x,f,g,cov,retcode } = maxprt(maxlik(dataset1,0,&lprnorm1,bb1));
		
		/*Calculation of the Sandwich standard error*/
		//Hessian      = _max_FinalHess*nobs;//*nobs; @_max_HessCov is the Hessian supplied by GAUSS@
		
		//if(det(Hessian) > 0);
			//Hessian_inv  = inv(Hessian);
		//endif;
	
		/*needx = selif(x,_max_active); @x contains the parameter estimates; needx holds only the  parameter estimates that are active@
		
		mm = 1;
		index = zeros(sumc(_max_active),1);
		//print "index: " index;
		for m(1,rows(_max_active),1);
			if(_max_active[m] .== 1);
				index[mm] = m;
			    mm = mm + 1;
			endif;
		endfor;	
 //print "cov: " sqrt(diag(inv(cov[index,index]*nobs)));
       cov_St_Error =  sqrt(diag(cov[index,index]));*/

		/*if(det(Hessian) > 0);
			Hessian_St_Error = sqrt(diag(Hessian_inv));
		else;
			Hessian_St_Error = zeros(rows(needx),1);
		endif;*/

	/*Gradient_Store is a nobs x nparam matrix which stores the analytical gradient, where nparam is the total number of parameters*//*Transposing it and getting the rows that are not fixed*/
	/***The diagonal elements (Kx1 vector) of Cross_Product are (lnLL(i)/beta(k))^2 summed over i = 1 to nobs***/
	//Cross_Product1 = selif(gradient_Store1',_max_active); 
	//Cross_Product  = Cross_Product1*Cross_Product1'; @Calculating the Jacobian/Outer product@
	//st_err_out_prod   = sqrt(diag(inv(Cross_Product)));
	//Cov_BHHH       = Hessian_inv*Cross_Product*Hessian_inv; @Page 17 of the paper@
	//Var_BHHH       = diag(Cov_BHHH);

	/*Negative_Variance = (Var_BHHH .<0);
	//print "sumc(Negative_Variance)" sumc(Negative_Variance);
	Var_BHHH = (Var_BHHH .<0 ).* var_out_prod + (Var_BHHH .>0).*Var_BHHH;*/
	//st_error_BHHH = sqrt(Var_BHHH);

	//dummy_cols = count*ones(rows(needx),1);//~j*ones(rows(needx),1); @First column represents the repitition of the error, the second column the repitition of the permutation@
	//print "rows(x)" rows(x) "rows(cov)" rows(cov) "rows(dummy_col)" rows(dummy_col);
	//final_result = final_result|(dummy_cols~seqa(1,1,rows(needx))~needx~st_error_BHHH~Hessian_St_Error~st_err_out_prod);
	//final_result = final_result|(dummy_cols~seqa(1,1,rows(needx))~needx~cov_St_Error);
	//clearg _max_Maxiters, _max_CovPar;
 //endfor;
	//count = count+1;
 //endfor;
 
 //outwidth 240;
 //output file = FourOrd_5alt_1500Obs_50sets_AnaGrad_Code7_Part1_HetErr.asc reset;
 //print final_result;
 //call lpr(bb2,dataMat);



/******************************************************************************
                          Procedure definitions begin: MDCMP
******************************************************************************/
proc lprnorm(x,dta);
 local wt,xbase, xdel,xsigm,xsigmm,xgam,xsd,xcov,v2,w2,u2,j,k, v,vv, Vf,w,u,a,f,b,m,mq,cqq,cq,sel,Jac,e,d, ww1;
 local covb,covn,ident,min1,p4,seedn,sq,app1,hj,zj,covj,corrj,p1,p2,p2_temp, ch,nch,mear_ch, ha,hb,mu,mu_final,omegacov,omegacorr,z1,count, dummy;
 local Alpha_coeff, Chol_Alpha_corr, delta_coeff, d_matrix_coeff, Psi_chol, Lambda_coeff, Lambda, Alpha_corr, D_matrix, Psi_matrix, AlphaW, z,y;
 local U_Y, Full_error, e1, e12, e21, e22,  Mmat, UY_Tild, Error_Tild, mean_one, err_one_var, mean_one_obs, mean_two, err_two_var, cov_one_two, mean_two_changed, err_two_changed, mean_two_final, err_two_varf, err_two_corrf, err_two_final; 
 local lower_threshold,upper_threshold, lower_threshold_matrix, upper_threshold_matrix, lower_threshold_mat, upper_threshold_mat;
 local g1,g2, rho_low_g1, rho_low_g2, rho_up_g1, rho_up_g2, corr_g1g2, S, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc, SS;
 local p3, p3_temp, p3_temp_low, p3_temp_up, rho_low_g3, rho_up_g3, g3, lower_threshold_append, upper_threshold_append, mear_nch;
 local mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc, Chol_alpha_corr_adjusted, Chol_alpha_corr_adjusted1, temp;
 local p3_temp1, p3_temp2;

if(nvar_mear_ordl == 0);
	Alpha_coeff        =  x[1:nvarml]; @structural equation parameters@
	Chol_Alpha_corr    =  upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])); @Creates a matrix@
	delta_coeff        =  x[nvarml+nCholOmega+1:nvarml+nCholOmega+nvar_mear]; @Means of measurement equation@
	d_matrix_coeff     =  x[nvarml+nCholOmega+nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear]; @Factor loadings@
	Psi_chol           =  upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1])); @ms eq. error corr.@
	xbase 			   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm]; //Baseline utility parameters
	Lambda_coeff 	   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent]; //Latent variable coefficient into the baseline utility
	xdel  			   = eqmatdel'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)]; //Converts the no. of alpha parameters to be estimated to the total no. of alternatives, nc
	xgam  			   = eqmatgam'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)];//same as above
	xcov  				= upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)])); //Get the cholesky factors
 elseif(nvar_mear_ordl > 0);
	Alpha_coeff       =  x[1:nvarml]; @structural equation parameters@
	Chol_Alpha_corr    =  upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])); @Creates a matrix@
	delta_coeff        =  x[nvarml+nCholOmega+1:nvarml+nCholOmega+nvar_mear]; @Means of measurement equation@
	d_matrix_coeff     =  x[nvarml+nCholOmega+nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear]; @Factor loadings@
	Psi_chol           =  upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1])); @ms eq. error corr.@
	lower_threshold 	   = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl]; @The lower threshold vector@
    upper_threshold    = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+nvar_mear_ordl]; @The lower threshold vector@ 	
	xbase 			   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm]; //Baseline utility parameters
	Lambda_coeff 	   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent]; //Latent variable coefficient into the baseline utility
	xdel  			   = eqmatdel'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)]; //Converts the no. of alpha parameters to be estimated to the total no. of alternatives, nc
	xgam  			   = eqmatgam'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)];//same as above
	xcov  			   = upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)])); //Get the cholesky factors
endif;



	Chol_Alpha_corr_adjusted = Chol_Alpha_corr';
	Chol_Alpha_corr_adjusted1 = Chol_Alpha_corr';
		
	@Why doing this?@
	for i(2,rows(Beta_corr),1);
	for j(1,i,1);
		if (i ne j);
			temp = sumc(Chol_Alpha_corr_adjusted1[i,1:i-1]'.*Chol_Alpha_corr_adjusted1[i,1:i-1]');
			Chol_Alpha_corr_adjusted[i,j] = Chol_Alpha_corr_adjusted1[i,j]/sqrt(1+temp);
			clear temp;
		endif;
				
		if (i eq j);
			temp = sumc(Chol_Alpha_corr_adjusted1[i,1:i-1]'.*Chol_Alpha_corr_adjusted1[i,1:i-1]');
			Chol_Alpha_corr_adjusted[i,j] = 1/sqrt(1+temp);
			clear temp;
		endif;
	endfor;
 endfor;
	   
	Chol_Alpha_corr = Chol_Alpha_corr_adjusted';

 Alpha_corr = Chol_Alpha_corr' * Chol_Alpha_corr; //Get the variance-covariance matrix of the latent variable
 D_matrix   = reshape(d_matrix_coeff,nvar_mear, nvar_latent); //reshape the factor loadings in nvar_mear x nvar_latent format
 Psi_matrix = Psi_chol' * Psi_chol; //Get the variance-covariance matrix of the indicators
 Lambda 	= reshape(Lambda_coeff, nc, nvar_latent); //  Reshape the Lambda_coeff into nc by nvar_latent format
 covn = xcov'*xcov; //xcov is a upper triangular matrix
 @covn is already an nc by nc matrix@
 //covn = zeros(1,nc)|(zeros(nc-1,1)~covn); //appending zero row on top and zero row on bottom
 
 if(nvar_mear_ordl > 0); @Next block of code assiging the lower and the upper threshold for each individual depending on their ordinal indicator response@
		lower_threshold_matrix = zeros(nobs, nvar_mear_ordl);
		upper_threshold_matrix = zeros(nobs, nvar_mear_ordl);
		
		lower_threshold_mat = ones(nobs,1) .*. lower_threshold'; @Converting the lower threshold into a row vector@
		upper_threshold_mat = ones(nobs,1) .*. upper_threshold'; @Converting the upper thershold into a row vector@
		
		lower_threshold_matrix[.,.] = (dta[.,ivgenyo] .<=1) .* negative_infinity + ((dta[.,ivgenyo].>=2) .and (dta[.,ivgenyo].<=4))  .* 0 + (dta[.,ivgenyo].>=5) .* upper_threshold';
		upper_threshold_matrix[.,.] = (dta[.,ivgenyo] .<=1) .* 0 + ((dta[.,ivgenyo].>=2).and (dta[.,ivgenyo].<=4))  .* upper_threshold' + (dta[.,ivgenyo].>=5) .* positive_infinity; 	
	endif;
	
	

 AlphaW = (ones(nvar_latent,1) .*. Alpha_coeff  )*~(dta[.,ivl])';
 z = {}; j = 1;	
 do until j > nvar_latent;
	z = z~(sumc(AlphaW[(j-1)*nvarml+1:(j*nvarml),.]));                // Z stores the latent variables value for each observation. nobs X nvar_latent. 1st col has z1, 2nd z2 and so on for all observations.
    j = j+1;
endo;
  
 @For each measurement equation, factor loading gets mult. by teh latent variable and summed up@
 y = ((D_matrix * z') + delta_coeff)'; // Y stores the Y variables value for each observation. nobs X nvar_mear. 1st col has Y1, 2nd Y2 and so on for all observations.

//multiply the variables with the appropriate betas for all the alternatives
 v2 = (ones(nc,1) .*. xbase)*~(dta[.,ivm])';
 w2 = (ones(nc,1) .*. xdel)*~(dta[.,ivd])'; //For alpha
 u2 = (ones(nc,1) .*. xgam)*~(dta[.,ivg])'; //For gamma

//Sum the deterministic portion of the utility, alpha and gamma
 j=1;
 v = {};
 w = {};
 u = {};
 do until j == nc+1;
   v = v~(sumc(v2[(j-1)*nvarm+1:(j*nvarm),.]));			// beta*zeta deterministic
   w = w~(sumc(w2[(j-1)*nvardel+1:(j*nvardel),.]));		// alpha
   u = u~(sumc(u2[(j-1)*nvargam+1:(j*nvargam),.]));		// gamma
   j = j+1;
 endo;
 //At the end of the loop, v, w and u are nobs x nc matrices

 vv = v + (Lambda * z')'; //Add latent variable into the baseline utility
 
 clear v2,w2,u2;
 
 @Convertion of alpha parameter@
 a = exp(w);		
 if _alp0to1;
   a = 1/(1+exp(w)); 		// a is 1-alpha
 endif;
 
 @Conversion of gamma parameter@
 f = exp(u);				// gamma
 b = dta[.,flagchm] .> 0;	// 1 if chosen, 0 if not //A nobs x nc matrix
 m = sumc(b');				// number of chosen alternatives  //an nobs x 1 column vector
 
 // Identifying alternative mq
 mq = b.* (seqa(1,1,nc))'; //Convert the 1's into the serial number of the alternatives
 mq = substute(mq,b.==0,nc+1); //Give a number greater than the total number of alternatives to the unchosen alternatives
 mq = minc(mq'); //Select the id of the first chosen alternative //mq is a nobs x 1 column vector
 
 //All the matrices in this equation are nobs x nc, must require the use of dot operator
 Vf = vv-a.*ln((dta[.,flagchm]+f)./f)-ln(dta[.,flagprcm]);	// deterministic component V //An nobs by nc matrix

 //Taking differences w/r to alternative mq
 cqq = reshape(((seqa(1,1,nc).*.ones(1,nobs)))', nobs*nc, 1 ); //cqq is a column of the seq of alternative numbers repeated nobs times
 cq = reshape(b, nobs*nc, 1 ); //Convert b into a column, where the seq is the participation indicator for 1st obs then for second observation and so on
 sel = cqq.*(cqq .!= (mq.*.ones(nc,1)));
 cq = reshape(selif(cq, cqq .== sel), nobs, nc-1); //cq is b arranged an nobs x (nc- 1) matrix//alternatives are 1 0 with 1 for selected and 0 for non-selected
 
 //Jacobian computation - not dividing by the price of mq, 
 //Correct if no price variation - need to correct if there is price variation
 Jac = (a.*b)./((dta[.,flagchm]+f));
 Jac = Jac./(dta[.,flagprcm]); 
 Jac = substute(Jac,b.==0,1); //
 e = (1/Jac).*b;  //nobs x nc matrix
 d = sumc((e'));//nobs x 1, the summation portion of the Jacobian
 Jac = (prodc((Jac'))).*d; //An nobs by 1 matrix
 
 U_Y = (y'|Vf')'; //concatenating the continuous indicator and the deterministinc portion of the utility
 e1   = ( D_matrix * Alpha_corr * D_matrix' + Psi_matrix ); @An nvar_mear x nvar_mear matrix@
 e12  = ( D_matrix * Alpha_corr * Lambda'); @nvar_mear x nc matrix@
 e21  = ( Lambda * Alpha_corr * D_matrix'); @nc x nvar_mar matrix@
 e22  = ( Lambda * Alpha_corr * Lambda' + covn); @nc x nc matrix@
 
 //print "e22: " e22;
	   
 @Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
 Full_error = (e1~e12);
 Full_error = Full_error | (e21~e22);
  
//Next two code blocks create the M matrix
 Mmat = zeros((nvar_mear+nc-1),(nvar_mear+nc));
 Mmat[1:nvar_mear,1:nvar_mear] = eye(nvar_mear);
 ident = eye(nc-1);
 min1 = -ones(nc-1,1);
 p4 = {};
 seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
 sq = seedn;
 
 j=1;//Begining of the loop through the individual
 do while j <= nobs;
 //do while j <= 10;
	// Covariance ident - Creating the capital M matrix
	if mq[j]==nc;
		app1 = ident~min1;	
	elseif mq[j]==1;
		app1 = min1~ident;	  
	else;
		app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
	endif;
	
	Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

    UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
	Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
    //print "j: " j "Error_Tild: " Error_Tild;
   
	// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
	if m[j] == 1;
		if(nvar_mear_cont>0);
			mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
			mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
			err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
			mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
			err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
			p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
		else;
			mean_two_final = UY_Tild;
			err_two_final = Error_Tild;
			
			p1 = 1;
		endif;
			
		if(nvar_mear_ordl > 1);
			p2 = 1; 
			for g1(1,nvar_mear_ordl-1,1);
				for g2(g1+1,nvar_mear_ordl,1);
					rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
					rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
					rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
					rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
					corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
					p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
					p2_temp = p2_temp.^(1/(nvar_mear_ordl));
					p2 = p2*p2_temp; @Contains the multiplication of the ordinal indictaor probabilities@
					
					clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
				endfor;
			endfor;
		else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
			p2 = 1;
		endif;
		
		if(nvar_mear_ordl > 0);
		   lower_threshold_append = {}; upper_threshold_append = {}; 
		   lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
		   upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
		   @This is a modified lower threshold vector that actually holds the lower thresholds for the ordinal indicators but upper threshold for the non-chosen alternatives@
		   lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@ 
		   upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
		   p3 = 1;
		   for g3(1,nvar_mear_ordl,1);
			S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
		    S[1,g3] = 1; @Put an 1 in the first row and g3th column@
		    S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
		    rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		    rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
		    mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
		    var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			//print "j: " j  "g3: " g3 "var_ordl_nc: " var_ordl_nc;
			
			st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
		    mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
		    mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
		    corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
		    corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
			//print "j: " j  "g3: " g3 "corr_ordl_nc: " corr_ordl_nc;
			
			@The difference between the lower and in the upper threshold is only in the threshold that has been used@
			if(nc == 2);
				p3_temp = cdfMvn(mean_up_final, corr_ordl_nc) - cdfMvn(mean_low_final, corr_ordl_nc);
				print "This line will never be printed with nc > = 3";
			else; @cdfmvna() can only be used when nc is greater than 2@
				{ p3_temp1,sq } = cdfmvna(mean_up_final',corr_ordl_nc,seedn); @this is dealing with a  nc dimenssional integral@
				if (rho_low_g3[1] .== negative_infinity);
					p3_temp = p3_temp1;
				else;
					{ p3_temp2,sq } = cdfmvna(mean_low_final',corr_ordl_nc,seedn); @this is dealing with a  nc dimenssional integral@
					p3_temp = p3_temp1 - p3_temp2;
				endif;
			endif;
			p3_temp = p3_temp.^(1/nvar_mear_ordl); @nc is the total number of alternatives, m[j] holds the number of alternatives consumed@
			p3 = p3*p3_temp;
		  	clear p3_temp, p3_temp1, p3_temp2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
		endfor;
		
		
		else; @If there are no ordinal indicators@
			mean_nc  = mean_two_final; 
			var_nc   = err_two_final; 
		
			st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
			mean_nc_final = (- mean_nc)./st_err_nc;
			corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
			corr_nc   = diagrv(corr_nc,ones(nc-1,1));
			
			if(nc-1 == 2);
				p3 = cdfMvn(mean_nc_final, corr_nc);
			else;
				{ p3,sq } = cdfmvna(mean_nc_final',corr_nc,seedn);	
			endif;
		endif; @End of calccualtion for p1, p2, p3@
		clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
	
	// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
	elseif m[j] == nc;
		if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
			S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
			S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
			S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
			mean_one = S*UY_Tild;
			mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
			err_one_var = S*Error_Tild*S';
		else; @No continuous indicators - only chosen alternatives@
			S = zeros((nc-1),(nvar_mear_ordl+nc-1));
			S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
			mean_one = S*UY_Tild;
			mean_one_obs = zeros(nc-1,1);
			err_one_var = S*Error_Tild*S';
		endif;
		
		p1 = Jac[j]*pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
		
		@Joint normal cdf needs to be calculated only for the ordinal indicators@
		if(nvar_mear_ordl > 0);
			mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
			SS = {};
			if(nvar_mear_cont>0);
				SS = SS|seqa(1,1,nvar_mear_cont);
			endif;
			SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @Ge the location of the chosen alternatives@
			cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
		
			@If more than one ordinal indicators - need to consider pair of them@
			if(nvar_mear_ordl > 1);	
				p2 = 1;
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
						p2_temp = p2_temp.^(1/(nvar_mear_ordl-1));
						p2 = p2*p2_temp; @Contains the multiplication of the ordinal indictaor probabilities@
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
					endfor;
				endfor;
			elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
				mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
			endif;
		else; @If no ordinal indicators@
			p2 = 1;	
		endif;
		@In this case p3 is always 1 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
		p3 = 1;
		
		clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
		// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
				k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
		
			p1 = Jac[j]*pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			//print "j: " j  "err_two_final: " err_two_final;
		
			if(nvar_mear_ordl > 1);
				p2 = 1; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
						p2_temp = p2_temp.^(1/(nvar_mear_ordl));
						p2 = p2*p2_temp; @Contains the multiplication of the ordinal indictaor probabilities@
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2 = 1;
			endif; @End of calculation of p2 - considering the pairs of the ordinals@
		
			if(nvar_mear_ordl > 0); @Sart of calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				@This is a new lower threshold where the lower thresholds have been used for the ordinal indicators and upper threshold has been used for the non-chosen alternative@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3 = 1;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
					//print "j: " j  "g3: " g3 "cor_ordl_nc: " corr_ordl_nc;
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfMvn(mean_up_final, corr_ordl_nc) - cdfMvn(mean_low_final, corr_ordl_nc);
					else; @cdfmvna() can only be used when nc is greater than 2@
						{ p3_temp1,sq } = cdfmvna(mean_up_final',corr_ordl_nc,seedn); @This is dealing with a three dimenssional integral@
						if(rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
						else;
							{ p3_temp2,sq } = cdfmvna(mean_low_final',corr_ordl_nc,seedn);
							p3_temp = p3_temp1 - p3_temp2;
						endif;
					endif;
					p3_temp = p3_temp.^(1/nvar_mear_ordl); @nch holds the number of non-chosen alternatives@
					p3 = p3*p3_temp;
					clear p3_temp, p3_temp1, p3_temp2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
				endfor;
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./st_err_nc;
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
				elseif(rows(nch)==2);
					p3 = cdfMvn(mean_nc_final, corr_nc);
				else;
					{ p3,sq } = cdfmvna(mean_nc_final',corr_nc,seedn);	
				endif;
			endif; @End of calccualtion for p3@
		clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
		endif; @End of check for how many alternatives have been consumed@
		
		//print "j: " j "m[j]" m[j] "p1: " p1 "p2: " p2 "p3: " p3;
		
		p4 = p4|(p1*p2*p3); 
		if (m[j] == 1);
			//print "m[j], p4[j]: " m[j] p1 p2 p3 p4[j];
			//print "seedn: " seedn;
		endif;
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	//ww1 = zeros(5,1);
	ww1=zeros(nobs,1);
	if p4 > ww1;
		z1 = ln(p4);
		post_obs = ones(nobs,1);
	else;
		z1=ln(p4-((p4.<=ww1).*(p4-0.0001)));
		post_obs = ((p4.<=ww1).*0)+(p4.>ww1);
	endif;
	retp(z1);
	endp;

proc lgdnorm(x,dta);
 local wt,xbase, xdel,xsigm,xsigmm,xgam,xsd,xcov,v2,w2,u2,j,k, v,vv, Vf,w,u,a,f,b,m,mq,cqq,cq,sel,Jac,e,d, ww1;
 local covb,covn,ident,min1,p4,seedn,sq,app1,hj,zj,covj,corrj,p1,p2,p2_temp, ch,nch,mear_ch, ha,hb,mu,mu_final,omegacov,omegacorr,z1,count, dummy;
 local Alpha_coeff, Chol_Alpha_corr, delta_coeff, d_matrix_coeff, Psi_chol, Lambda_coeff, Lambda, Alpha_corr, D_matrix, Psi_matrix, AlphaW, z,y;
 local U_Y, Full_error, e1, e12, e21, e22,  Mmat, UY_Tild, Error_Tild, mean_one, err_one_var, mean_one_obs, mean_two, err_two_var, cov_one_two, mean_two_changed, err_two_changed, mean_two_final, err_two_varf, err_two_corrf, err_two_final; 
 local lower_threshold,upper_threshold, lower_threshold_matrix, upper_threshold_matrix, lower_threshold_mat, upper_threshold_mat;
 local g1,g2, rho_low_g1, rho_low_g2, rho_up_g1, rho_up_g2, corr_g1g2, S, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc, SS;
 local p3, p3_temp, p3_temp_low, p3_temp_up, rho_low_g3, rho_up_g3, g3, lower_threshold_append, upper_threshold_append, mear_nch;
 local mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc, e1_d, e12_d, e21_d, e22_d, Full_error_d;
 local Alpha_corr_d, Psi_matrix_d, covn_d, alpha_z_score, iAlpha, alpha_coeff_d, AlphaWd, zd, yd, Vfd, U_Yd, gg_temp, gg, p1_dd;
 local UY_Tild_d, Error_Tild_d, mean_one_d, mean_one_obs_d, err_one_var_d, mean_two_d, err_two_var_d, cov_one_two_d, mean_two_final_d, err_two_final_d, p1_d, p1_dm, p1_dr;
 local rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, corr_g1g2_d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p3_temp_up_d, p3_temp_low_d;
 local mean_ordl_nc_d, var_ordl_nc_d, st_err_ordl_nc_d, mean_low_final_d, mean_up_final_d, corr_ordl_nc_d, p3_temp_d ;
 local mean_nc_d, var_nc_d, st_err_nc_d, mean_nc_final_d, corr_nc_d,p3_d, p3_dd, p2_dd, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
 local gradient, alpha_corr_score, ia_corr, d_chol_alpha_corr, Alpha_corr_dd, shi_r_unq, ishi, delta_coeff_score, delta_coeff_d, iDelta, dmatrix_score, dmatrix_coeff_d, iDmat;
 local Psi_score, iPsi, Psi_chol_d, Psi_matrix_dd, lower_threshold_score, lower_threshold_d, lower_threshold_matrix_d, upper_threshold_score, upper_threshold_d, upper_threshold_matrix_d, iLower_th, iUpper_th, lower_threshold_mat_d, upper_threshold_mat_d;
 local lower_threshold_append_d, upper_threshold_append_d, rho_low_g3_d, rho_up_g3_d, beta_score, iBeta, xbase_d, v2_d, v_d, lambda_score, iLambda, lambda_coeff_d, lambda_mat_d;
 local covn_score, iCov, covn_chol_dd, covn_dd, alpha_score, iAlpha_sat, xdel_grad, w2_grad, w_grad, a_grad, jac_grad1, jac_grad2_top, jac_grad2_bottom, jac_grad2, jac_grad;
 local gamma_score, iGamma, xgam_grad, u2_grad, u_grad, f_grad, icheck, jcheck, d_chol_alpha_corr1, temp, Chol_Alpha_corr_adjusted, Chol_Alpha_corr_adjusted1;
 local p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2;
 
 nobs = rows(dta);  post_obs = ones(nobs,1);
 
 
 
if(nvar_mear_ordl == 0);
	Alpha_coeff        =  x[1:nvarml]; @structural equation parameters@
	Chol_Alpha_corr    =  upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])); @Creates a matrix@
	delta_coeff        =  x[nvarml+nCholOmega+1:nvarml+nCholOmega+nvar_mear]; @Means of measurement equation@
	d_matrix_coeff     =  x[nvarml+nCholOmega+nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear]; @Factor loadings@
	Psi_chol           =  upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1])); @ms eq. error corr.@
	xbase 			   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm]; //Baseline utility parameters
	Lambda_coeff 	   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent]; //Latent variable coefficient into the baseline utility
	xdel  			   = eqmatdel'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)]; //Converts the no. of alpha parameters to be estimated to the total no. of alternatives, nc
	xgam  			   = eqmatgam'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)];//same as above
	xcov  				= upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)])); //Get the cholesky factors
 elseif(nvar_mear_ordl > 0);
	Alpha_coeff       =  x[1:nvarml]; @structural equation parameters@
	Chol_Alpha_corr    =  upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])); @Creates a matrix@
	delta_coeff        =  x[nvarml+nCholOmega+1:nvarml+nCholOmega+nvar_mear]; @Means of measurement equation@
	d_matrix_coeff     =  x[nvarml+nCholOmega+nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear]; @Factor loadings@
	Psi_chol           =  upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1])); @ms eq. error corr.@
	lower_threshold 	   = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl]; @The lower threshold vector@
    upper_threshold    = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+nvar_mear_ordl]; @The lower threshold vector@ 	
	xbase 			   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm]; //Baseline utility parameters
	Lambda_coeff 	   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent]; //Latent variable coefficient into the baseline utility
	xdel  			   = eqmatdel'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)]; //Converts the no. of alpha parameters to be estimated to the total no. of alternatives, nc
	xgam  			   = eqmatgam'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)];//same as above
	xcov  			   = upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)])); //Get the cholesky factors
endif;
	
	Chol_Alpha_corr_adjusted = Chol_Alpha_corr';
	Chol_Alpha_corr_adjusted1 = Chol_Alpha_corr';
		
	@Why doing this?@
	for i(2,rows(Beta_corr),1);
		for j(1,i,1);
			if (i ne j);
				temp = sumc(Chol_Alpha_corr_adjusted1[i,1:i-1]'.*Chol_Alpha_corr_adjusted1[i,1:i-1]');
				Chol_Alpha_corr_adjusted[i,j] = Chol_Alpha_corr_adjusted1[i,j]/sqrt(1+temp);
				clear temp;
			endif;
				
			if (i eq j);
				temp = sumc(Chol_Alpha_corr_adjusted1[i,1:i-1]'.*Chol_Alpha_corr_adjusted1[i,1:i-1]');
				Chol_Alpha_corr_adjusted[i,j] = 1/sqrt(1+temp);
				clear temp;
			endif;
		endfor;
	endfor;
	   
	Chol_Alpha_corr = Chol_Alpha_corr_adjusted';
 
 Alpha_corr = Chol_Alpha_corr' * Chol_Alpha_corr; //Get the variance-covariance matrix of the latent variable
 D_matrix   = reshape(d_matrix_coeff,nvar_mear, nvar_latent); //reshape the factor loadings in nvar_mear x nvar_latent format
 Psi_matrix = Psi_chol' * Psi_chol; //Get the variance-covariance matrix of the indicators
 Lambda 	= reshape(Lambda_coeff, nc, nvar_latent); //  Reshape the Lambda_coeff into nc by nvar_latent format
 covn = xcov'*xcov; //xcov is a upper triangular matrix
 @covn is already a nc by nc matrix@
 //covn = zeros(1,nc)|(zeros(nc-1,1)~covn); //appending zero row on top and zero row on bottom
 
 Alpha_corr_d = zeros(nvar_latent,nvar_latent);
 Psi_matrix_d = zeros(nvar_mear,nvar_mear);
 covn_d      = zeros(nc,nc);
 
 if(nvar_mear_ordl > 0); @Next block of code assiging the lower and the upper threshold for each individual depending on their ordinal indicator response@
		lower_threshold_matrix = zeros(nobs, nvar_mear_ordl);
		upper_threshold_matrix = zeros(nobs, nvar_mear_ordl);
		
		//lower_threshold_mat = ones(nobs,1) .*. lower_threshold'; @Converting the lower threshold into a row vector@
		//upper_threshold_mat = ones(nobs,1) .*. upper_threshold'; @Converting the upper thershold into a row vector@
		
		lower_threshold_matrix[.,.] = (dta[.,ivgenyo] .<=1) .* negative_infinity + ((dta[.,ivgenyo].>=2) .and (dta[.,ivgenyo].<=4))  .* 0 + (dta[.,ivgenyo].>=5) .* upper_threshold';
		upper_threshold_matrix[.,.] = (dta[.,ivgenyo] .<=1) .* 0 + ((dta[.,ivgenyo].>=2).and (dta[.,ivgenyo].<=4))  .* upper_threshold' + (dta[.,ivgenyo].>=5) .* positive_infinity; 	
 endif;

 AlphaW = (ones(nvar_latent,1) .*. Alpha_coeff  )*~(dta[.,ivl])';
 z = {}; j = 1;	
 do until j > nvar_latent;
	z = z~(sumc(AlphaW[(j-1)*nvarml+1:(j*nvarml),.]));                // Z stores the latent variables value for each observation. nobs X nvar_latent. 1st col has z1, 2nd z2 and so on for all observations.
    j = j+1;
endo;
  
 @For each measurement equation, factor loading gets mult. by teh latent variable and summed up@
 y = ((D_matrix * z') + delta_coeff)'; // Y stores the Y variables value for each observation. nobs X nvar_mear. 1st col has Y1, 2nd Y2 and so on for all observations.

//multiply the variables with the appropriate betas for all the alternatives
 v2 = (ones(nc,1) .*. xbase)*~(dta[.,ivm])';
 w2 = (ones(nc,1) .*. xdel)*~(dta[.,ivd])'; //For alpha
 u2 = (ones(nc,1) .*. xgam)*~(dta[.,ivg])'; //For gamma

//Sum the deterministic portion of the utility, alpha and gamma
 j=1;
 v = {};
 w = {};
 u = {};
 do until j == nc+1;
   v = v~(sumc(v2[(j-1)*nvarm+1:(j*nvarm),.]));			// beta*zeta deterministic
   w = w~(sumc(w2[(j-1)*nvardel+1:(j*nvardel),.]));		// alpha
   u = u~(sumc(u2[(j-1)*nvargam+1:(j*nvargam),.]));		// gamma
   j = j+1;
 endo;
 //At the end of the loop, v, w and u are nobs x nc matrices

 vv = v + (Lambda * z')'; //Add latent variable into the baseline utility
 
 clear v2,w2,u2;
 
 @Convertion of alpha parameter@
 a = exp(w);		
 if _alp0to1;
   a = 1/(1+exp(w)); 		// a is 1-alpha
 endif;
 
 @Conversion of gamma parameter@
 f = exp(u);				// gamma
 b = dta[.,flagchm] .> 0;	// 1 if chosen, 0 if not //A nobs x nc matrix
 m = sumc(b');				// number of chosen alternatives  //an nobs x 1 column vector
 
 // Identifying alternative mq
 mq = b.* (seqa(1,1,nc))'; //Convert the 1's into the serial number of the alternatives
 mq = substute(mq,b.==0,nc+1); //Give a number greater than the total number of alternatives to the unchosen alternatives
 mq = minc(mq'); //Select the id of the first chosen alternative //mq is a nobs x 1 column vector
 
 //All the matrices in this equation are nobs x nc, must require the use of dot operator
 Vf = vv-a.*ln((dta[.,flagchm]+f)./f)-ln(dta[.,flagprcm]);	// deterministic component V //An nobs by nc matrix

 //Taking differences w/r to alternative mq
 cqq = reshape(((seqa(1,1,nc).*.ones(1,nobs)))', nobs*nc, 1 ); //cqq is a column of the seq of alternative numbers repeated nobs times
 cq = reshape(b, nobs*nc, 1 ); //Convert b into a column, where the seq is the participation indicator for 1st obs then for second observation and so on
 sel = cqq.*(cqq .!= (mq.*.ones(nc,1)));
 cq = reshape(selif(cq, cqq .== sel), nobs, nc-1); //cq is b arranged an nobs x (nc- 1) matrix//alternatives are 1 0 with 1 for selected and 0 for non-selected
 
 //Jacobian computation - not dividing by the price of mq, 
 //Correct if no price variation - need to correct if there is price variation
 Jac = (a.*b)./((dta[.,flagchm]+f));
 Jac = Jac./(dta[.,flagprcm]); 
 Jac = substute(Jac,b.==0,1); //
 e = (1/Jac).*b;  //nobs x nc matrix
 d = sumc((e'));//nobs x 1, the summation portion of the Jacobian
 Jac = (prodc((Jac'))).*d; //An nobs by 1 matrix
 
 U_Y = (y'|Vf')'; //concatenating the continuous indicator and the deterministinc portion of the utility
 e1   = ( D_matrix * Alpha_corr * D_matrix' + Psi_matrix ); @An nvar_mear x nvar_mear matrix@
 e12  = ( D_matrix * Alpha_corr * Lambda'); @nvar_mear x nc matrix@
 e21  = ( Lambda * Alpha_corr * D_matrix'); @nc x nvar_mar matrix@
 e22  = ( Lambda * Alpha_corr * Lambda' + covn); @nc x nc matrix@
	   
 @Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
 Full_error = (e1~e12);
 Full_error = Full_error | (e21~e22);
   
//Next two code blocks create the M matrix
 Mmat = zeros((nvar_mear+nc-1),(nvar_mear+nc));
 Mmat[1:nvar_mear,1:nvar_mear] = eye(nvar_mear);
 ident = eye(nc-1);
 min1 = -ones(nc-1,1);
 
  /***************************************************************************************************************************/
 /*Note: alpha_coeff is contained in the latent variable z, it will effect the means of the measurement equation i.e. y as well as
 the deterministic portion of the utility, i.e. Vf, but no error will be effected by the derivative, derivative need to be taken
 only w.r.t the mean of the joint normal pdf and the joint normal cdf*/
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Alpha_coeff*****************************************************************/
 
 alpha_z_score = {};
 for iAlpha(1,nvarml,1);
	 if(_max_active[iAlpha] == 0);
		 alpha_z_score = alpha_z_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 alpha_coeff_d = zeros(nvarml,1); //A column vector
		 alpha_coeff_d[iAlpha] = 1; //The derivative with respect to itself is 1
		 AlphaWd = (ones(nvar_latent,1) .*. alpha_coeff_d)*~(dta[.,ivl])';
		 
		 j = 1;
		 zd = {};	
		 do until j > nvar_latent;
			zd = zd~(sumc(AlphaWd[(j-1)*nvarml+1:(j*nvarml),.]));			
			j = j+1;
		 endo; //zd is a nobs x nvar_latent matrix
		
		yd = (D_matrix * zd')';		//yd is a nobs x nvar_mear matrix
		Vfd = (Lambda*zd')';  //Adding latent variable into the baseline utility
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					@new lower threshold, where lower thresholds of ordinal indicators are added with upper thresholds of the alternatives@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;
			
						clear p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, p3_temp, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					@Making a new lower threshold@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;
						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2,S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		alpha_z_score = alpha_z_score~gg_temp;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Alpha the cholesky factor of the error of the latent variable*****************************************************************/
 /***************ONLY AFFECTS THE ERRORS OF THE DISTRIBUTION*********************************************************************/
 
 alpha_corr_score = {};
 for ia_corr(1,nCholOmega,1);
	 if(_max_active[nvarml+ia_corr] == 0);
		 alpha_corr_score = alpha_corr_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 for icheck(1,rows(Chol_Corr_Map),1);
			for jcheck(1,cols(Chol_Corr_Map),1);
				if( (ia_corr eq Chol_Corr_Map[icheck,jcheck]) AND (Beta_corr_active[icheck,jcheck] eq 1) );
		   
					d_chol_alpha_corr1 = zeros(rows(Chol_Corr_Map),rows(Chol_Corr_Map));  
					temp = sumc(Chol_Alpha_corr_adjusted1[icheck,1:icheck-1]'.*Chol_Alpha_corr_adjusted1[icheck,1:icheck-1]');  
					d_chol_alpha_corr1[icheck,jcheck]= (1/sqrt(1+temp)) - ( (Chol_Alpha_corr_adjusted1[icheck,jcheck]^2)/ ( (1+temp)^(3/2) ) ); 
					d_chol_alpha_corr1[jcheck,icheck]= d_chol_alpha_corr1[icheck,jcheck];  
					d_chol_alpha_corr1[icheck,icheck] = (- Chol_Alpha_corr_adjusted1[icheck,jcheck])/ ( (1+temp)^(3/2) );  
                    clear temp;					   
				  endif;
			   endfor;
		endfor;
		d_chol_alpha_corr = upmat(d_chol_alpha_corr1); @Making it an upper triangular matrix@
		  
		Alpha_corr_dd = d_chol_alpha_corr'*Chol_Alpha_corr + Chol_Alpha_corr'*d_chol_alpha_corr;
		 
		yd = zeros(nobs,nvar_mear);		//yd is a nobs x nvar_mear matrix
		Vfd = zeros(nobs,nc);  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( D_matrix * Alpha_corr_dd * D_matrix' + Psi_matrix_d ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( D_matrix * Alpha_corr_dd * Lambda'); @nvar_mear x nc matrix@
		e21_d  = ( Lambda * Alpha_corr_dd * D_matrix'); @nc x nvar_mar matrix@
		e22_d  = ( Lambda * Alpha_corr_dd * Lambda' + covn_d); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;
			
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/(nvar_mear_ordl))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;
						
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	alpha_corr_score = alpha_corr_score~gg_temp;
	clear d_chol_alpha_corr, Alpha_corr_dd;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Delta - The constants in the measurement equation*****************************************************************/
 /*****************************************Only affects the mean of the distribution**************************************************************************************/
 delta_coeff_score = {};
 for iDelta(1,nvar_mear,1); @nvar_mear contains the sum of the continuoous and the ordinal indicators@
	 if(_max_active[nvarml+nCholOmega+iDelta] == 0);
		delta_coeff_score = delta_coeff_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		delta_coeff_d = zeros(nvar_mear,1); //A column vector
		delta_coeff_d[iDelta] = 1; //The derivative with respect to itself is 1 @@
		
		yd = (ones(nobs,1) .*. delta_coeff_d');		//yd is a nobs x nvar_mear matrix
		Vfd = zeros(nobs,nc);  //Adding latent variable into the baseline utility
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators - no need to condition on the conitnuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;
			
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;
						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		delta_coeff_score = delta_coeff_score~gg_temp;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@

/****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO d_matrix, the factor loading*****************************************************************/
 /********************************AFFECTS BOTH THE MEAN AND THE ERRORS OF THE DISTRIBUTION*********************************************************************/ 
 dmatrix_score = {};
 for iDmat(1,nvar_mear*nvar_latent,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+iDmat] == 0);
		dmatrix_score = dmatrix_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		dmatrix_coeff_d = zeros(nvar_mear*nvar_latent,1); //A column vector
		dmatrix_coeff_d[iDmat] = 1;
		dmatrix_coeff_d = reshape(dmatrix_coeff_d, nvar_mear, nvar_latent);
		 
		yd = (dmatrix_coeff_d * z')'; @nobs x nvar_mear matrix@
		Vfd = zeros(nobs,nc);  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( dmatrix_coeff_d*Alpha_corr*D_matrix' + D_matrix*Alpha_corr*dmatrix_coeff_d' + Psi_matrix_d ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( dmatrix_coeff_d*Alpha_corr*Lambda'); @nvar_mear x nc matrix@
		e21_d  = ( Lambda*Alpha_corr*dmatrix_coeff_d'); @nc x nvar_mar matrix@
		e22_d  = ( Lambda*Alpha_corr_d*Lambda' + covn_d); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_dm = pdfgmean(mean_one_obs, mean_one,err_one_var); @Returns column vector@
					p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d) + p1_dr'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;
			
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2,S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_dm = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d)+ p1_dr'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_dm = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
			p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d)+p1_dr'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;	
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	dmatrix_score = dmatrix_score~gg_temp;
	clear dmatrix_coeff_d;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Psi_matrix the error of the measurement equation *****************************************************************/
 /***************ONLY AFFECTS THE ERRORS OF THE DISTRIBUTION*********************************************************************/
 Psi_score = {};
 for iPsi(1,nCholOmega1,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+iPsi] == 0);
		 Psi_score = Psi_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 Psi_chol_d = zeros(nCholOmega1,1); //A column vector
		 Psi_chol_d[iPsi] = 1;
		 Psi_chol_d = upmat(xpnd(Psi_chol_d)); //The derivative with respect to itself is 1
		 Psi_matrix_dd = Psi_chol_d'*Psi_chol + Psi_chol'*Psi_chol_d;
		 
		yd = zeros(nobs,nvar_mear);		//yd is a nobs x nvar_mear matrix
		Vfd = zeros(nobs,nc);  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( D_matrix * Alpha_corr_d * D_matrix' + Psi_matrix_dd ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( D_matrix * Alpha_corr_d * Lambda'); @nvar_mear x nc matrix@
		e21_d  = ( Lambda * Alpha_corr_d * D_matrix'); @nc x nvar_mar matrix@
		e22_d  = ( Lambda * Alpha_corr_d * Lambda' + covn_d); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;
						clear p3_temp, p3_temp1, p3_temp2,p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;	
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2,S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	Psi_score = Psi_score~gg_temp; 
	clear Psi_chol_d, Psi_matrix_dd;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO lower threshold*****************************************************************/
 if(nvar_mear_ordl > 0);
 lower_threshold_score = {};
 for iLower_th(1,nvar_mear_ordl,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+iLower_th] == 0);
		lower_threshold_score = lower_threshold_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		lower_threshold_d = zeros(nvar_mear_ordl,1); @row vector@   
		lower_threshold_d[iLower_th] = 1;
		
		lower_threshold_mat_d = ones(nobs,1) .*. lower_threshold_d';
		upper_threshold_mat_d = zeros(nobs,nvar_mear_ordl);
		
		lower_threshold_matrix_d = zeros(nobs, nvar_mear_ordl);
		upper_threshold_matrix_d = zeros(nobs, nvar_mear_ordl);
	
		lower_threshold_matrix_d = (dta[.,ivgenyo] .<=1) .* negative_infinity_d + ((dta[.,ivgenyo].>=2).and(dta[.,ivgenyo].<=4) )  .* lower_threshold_mat_d + (dta[.,ivgenyo].>=5) .* upper_threshold_mat_d;
		upper_threshold_matrix_d = (dta[.,ivgenyo] .<=1) .* lower_threshold_mat_d + ((dta[.,ivgenyo].>=2).and(dta[.,ivgenyo].<=4) )  .* upper_threshold_mat_d + (dta[.,ivgenyo].>=5) .* positive_infinity_d; 	
			
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
								
					p1_dd = 0; @Always zero - while taking derivatives with respect to the thresholds@
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
							rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
				
				@No check - since, already chcked for the presence of ordinal indicator@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
				
				lower_threshold_append_d = {}; upper_threshold_append_d = {};
				lower_threshold_append_d = lower_threshold_append_d|lower_threshold_matrix_d[j,.]'; @Making it a column@
				lower_threshold_append_d = lower_threshold_append_d|zeros(nc-1,1);
				upper_threshold_append_d = upper_threshold_append_d|upper_threshold_matrix_d[j,.]'|zeros(nc-1,1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
					rho_low_g3_d = S*lower_threshold_append_d;
					rho_up_g3_d = S*upper_threshold_append_d;
						
					mean_low_final_d = (rho_low_g3_d)./st_err_ordl_nc;
					mean_up_final_d = (rho_up_g3_d)./st_err_ordl_nc;
			
					if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;

			
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				@End of calculation of p1_dd, p2_dd and p3_dd for the first case@
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
				endif;
				
				p1_dd = 0;
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
				err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
				SS = {};
				if(nvar_mear_cont>0);
					SS = SS|seqa(1,1,nvar_mear_cont);
				endif;
				SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
				cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
				@If more than one ordinal indicators - need to consider pair of them@
				if(nvar_mear_ordl > 1);	
				p2_dd = 0;
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
						rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
						rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
						rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
						p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
					endfor;
				endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
			elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
				mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
				mean_low_final_d = lower_threshold_matrix_d[j,1]/sqrt(err_two_final);
				mean_up_final_d = upper_threshold_matrix_d[j,1]/sqrt(err_two_final);
				p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
			endif;
			
			@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
				k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
			
			p1_dd = 0;	@Always zero while taking derivative with respect to the ordinal indicators@
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
						rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
						rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
						rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		    
			@No check, since already checked for the presence of ordinal indicators@
			lower_threshold_append = {}; upper_threshold_append = {}; 
			lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
			upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
			lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
			upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
					
			lower_threshold_append_d = {}; upper_threshold_append_d = {};
			lower_threshold_append_d = lower_threshold_append_d|lower_threshold_matrix_d[j,.]'|zeros(rows(nch),1);
			upper_threshold_append_d = upper_threshold_append_d|upper_threshold_matrix_d[j,.]'|zeros((rows(nch)),1);
					
			p3_dd = 0;
			for g3(1,nvar_mear_ordl,1);
				S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
				S[1,g3] = 1; @Put an 1 in the first row and g3th column@
				S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
				rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
				rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
	   
				mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
				var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
				st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
				mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
				mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
				corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
				rho_low_g3_d = S*lower_threshold_append_d;
				rho_up_g3_d = S*upper_threshold_append_d;
				
				mean_low_final_d = (rho_low_g3_d)./st_err_ordl_nc;
				mean_up_final_d = (rho_up_g3_d)./st_err_ordl_nc;
			
				if((rows(nch)+1) == 2);
					p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
					p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
					p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
					p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
				else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
					{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
					if (rho_low_g3[1] .== negative_infinity);
						p3_temp = p3_temp1;
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
					else;
						{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						p3_temp = p3_temp1 - p3_temp2;
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
					endif;
				endif;

						
				clear p3_temp,p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
				clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
			endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	lower_threshold_score = lower_threshold_score~gg_temp;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO UPPER THRESHOLD*****************************************************************/
 upper_threshold_score = {};
 for iUpper_th(1,nvar_mear_ordl,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+iUpper_th] == 0);
		upper_threshold_score = upper_threshold_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		upper_threshold_d = zeros(nvar_mear_ordl,1); @row vector@   
		upper_threshold_d[iUpper_th] = 1; @A column vector@
		
		lower_threshold_mat_d = zeros(nobs,nvar_mear_ordl);
		upper_threshold_mat_d = ones(nobs,1).*.upper_threshold_d';
		
		lower_threshold_matrix_d = zeros(nobs, nvar_mear_ordl);
		upper_threshold_matrix_d = zeros(nobs, nvar_mear_ordl);
	
		lower_threshold_matrix_d = (dta[.,ivgenyo] .<=1) .* negative_infinity_d + ((dta[.,ivgenyo].>=2).and(dta[.,ivgenyo].<=4) )  .* lower_threshold_mat_d + (dta[.,ivgenyo].>=5) .* upper_threshold_mat_d;
		upper_threshold_matrix_d = (dta[.,ivgenyo] .<=1) .* lower_threshold_mat_d + ((dta[.,ivgenyo].>=2).and(dta[.,ivgenyo].<=4) )  .* upper_threshold_mat_d + (dta[.,ivgenyo].>=5) .* positive_infinity_d; 	
			
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
								
					p1_dd = 0; @Always zero - while taking derivatives with respect to the thresholds@
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
							rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
				
				@No check - since, already chcked for the presence of ordinal indicator@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
				
				lower_threshold_append_d = {}; upper_threshold_append_d = {};
				lower_threshold_append_d = lower_threshold_append_d|lower_threshold_matrix_d[j,.]'|zeros(nc-1,1); @Making it a column@
				upper_threshold_append_d = upper_threshold_append_d|upper_threshold_matrix_d[j,.]'|zeros(nc-1,1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
					rho_low_g3_d = S*lower_threshold_append_d;
					rho_up_g3_d = S*upper_threshold_append_d;
						
					mean_low_final_d = (rho_low_g3_d)./st_err_ordl_nc;
					mean_up_final_d = (rho_up_g3_d)./st_err_ordl_nc;
			
					if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
						@This line is never touched with 3 or more alternatives@
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
					else; @cdfmvna() can only be used when nc is greater than 2@
						{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						if(rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
						else;
							{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
						endif;
					endif;

					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				@End of calculation of p1_dd, p2_dd and p3_dd for the first case@
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
				endif;
				
				p1_dd = 0;
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
				err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
				SS = {};
				if(nvar_mear_cont>0);
					SS = SS|seqa(1,1,nvar_mear_cont);
				endif;
				SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
				cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
				@If more than one ordinal indicators - need to consider pair of them@
				if(nvar_mear_ordl > 1);	
				p2_dd = 0;
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
						rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
						rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
						rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
						p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
					endfor;
				endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
			elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
				mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
				mean_low_final_d = lower_threshold_matrix_d[j,1]/sqrt(err_two_final);
				mean_up_final_d = upper_threshold_matrix_d[j,1]/sqrt(err_two_final);
				p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
			endif;
			
			@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
				k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
			
			p1_dd = 0;	@Always zero while taking derivative with respect to the ordinal indicators@
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
						rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
						rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
						rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
						p2_dd = p2_dd + (1/(nvar_mear_ordl))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		    
			@No check, since already checked for the presence of ordinal indicators@
			lower_threshold_append = {}; upper_threshold_append = {}; 
			lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
			upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
			lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
			upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
					
			lower_threshold_append_d = {}; upper_threshold_append_d = {};
			lower_threshold_append_d = lower_threshold_append_d|lower_threshold_matrix_d[j,.]'|zeros(rows(nch),1);
			upper_threshold_append_d = upper_threshold_append_d|upper_threshold_matrix_d[j,.]'|zeros(rows(nch),1);
					
			p3_dd = 0;
			for g3(1,nvar_mear_ordl,1);
				S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
				S[1,g3] = 1; @Put an 1 in the first row and g3th column@
				S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
				rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
				rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
	   
				mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
				var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
				st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
				mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
				mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
				corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
				rho_low_g3_d = S*lower_threshold_append_d;
				rho_up_g3_d = S*upper_threshold_append_d;
				
				mean_low_final_d = (rho_low_g3_d)./st_err_ordl_nc;
				mean_up_final_d = (rho_up_g3_d)./st_err_ordl_nc;
			
				if((rows(nch)+1) == 2);
					p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
					p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
					p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
					p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
				else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
					{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
					if (rho_low_g3[1] .== negative_infinity);
						p3_temp = p3_temp1;
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
					else;
						{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						p3_temp = p3_temp1 - p3_temp2;
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
					endif;
				endif;

						
				clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
				clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
			endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	upper_threshold_score = upper_threshold_score~gg_temp;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 endif; @END OF CHECK FOR THE PRESENSE OF ORDINAL INDICATORS@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO BETA*****************************************************************/
 beta_score = {};
 for iBeta(1,nvarm,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+iBeta] == 0);
		 beta_score = beta_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 xbase_d = zeros(nvarm,1); //A column vector
		 xbase_d[iBeta] = 1; //The derivative with respect to itself is 1
		 v2_d = (ones(nc,1) .*. xbase_d)*~(dta[.,ivm])';
		 
		 j = 1;
		 v_d = {};	
		 do until j > nc;
			v_d = v_d~(sumc(v2_d[(j-1)*nvarm+1:(j*nvarm),.]));			
			j = j+1;
		endo; //v_d is a nobs x nc matrix		
		
		yd = zeros(nobs,nvar_mear);		//yd is a nobs x nvar_mear matrix
		Vfd = v_d;  //Adding latent variable into the baseline utility
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;

						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;

						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		beta_score = beta_score~gg_temp;
		clear xbase_d, v2_d, v_d;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO lambda, THE COEFFICIENT OF THE LATENT VARIABLE INTO THE CHOICE MODEL UTILITY*****************************************************************/
 /********************************AFFECTS BOTH THE MEAN AND THE ERRORS OF THE DISTRIBUTION*********************************************************************/ 
 lambda_score = {};
 for iLambda(1,nc*nvar_latent,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+nvarm+iLambda] == 0);
		lambda_score = lambda_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		lambda_coeff_d = zeros(nc*nvar_latent,1); //A column vector
		lambda_coeff_d[iLambda] = 1;
		lambda_mat_d = reshape(lambda_coeff_d, nc, nvar_latent);
		 
		yd = zeros(nobs, nvar_mear); @nobs x nvar_mear matrix@
		Vfd = (lambda_mat_d*z')';  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( D_matrix*Alpha_corr_d*D_matrix' + Psi_matrix_d ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( D_matrix*Alpha_corr*lambda_mat_d'); @nvar_mear x nc matrix@
		e21_d  = ( lambda_mat_d*Alpha_corr*D_matrix'); @nc x nvar_mar matrix@
		e22_d  = ( lambda_mat_d*Alpha_corr*Lambda' + Lambda*Alpha_corr*lambda_mat_d' + covn_d); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_dm = pdfgmean(mean_one_obs, mean_one,err_one_var); @Returns column vector@
					p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d) + p1_dr'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;

			
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_dm = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d)+ p1_dr'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl - 1))* (1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_dm = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
			p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d)+p1_dr'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;
						
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	lambda_score = lambda_score~gg_temp;
	clear lambda_coeff_d, lambda_mat_d;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the lambda gradient@

/****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO covn THE ERROR OF THE CHOICE MODEL *****************************************************************/
 /***************ONLY AFFECTS THE ERRORS OF THE DISTRIBUTION*********************************************************************/
 covn_score = {};
 for iCov(1,ncov,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+iCov] == 0);
		 covn_score = covn_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 covn_chol_dd = zeros(ncov,1); //A column vector
		 covn_chol_dd[iCov] = 1;
		 covn_chol_dd = upmat(xpnd(covn_chol_dd)); //The derivative with respect to itself is 1
		 //covn_dd = zeros(nc,nc);
		 //covn_dd[2:nc,2:nc] = covn_chol_dd'*xcov + xcov'*covn_chol_dd;
		 @Both covn_chol_dd and xcov are already nc by nc matrices@
		 covn_dd = covn_chol_dd'*xcov + xcov'*covn_chol_dd;
		 
		yd = zeros(nobs,nvar_mear);		//yd is a nobs x nvar_mear matrix
		Vfd = zeros(nobs,nc);  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( D_matrix * Alpha_corr_d * D_matrix' + Psi_matrix_d ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( D_matrix * Alpha_corr_d * Lambda'); @nvar_mear x nc matrix@
		e21_d  = ( Lambda * Alpha_corr_d * D_matrix'); @nc x nvar_mar matrix@
		e22_d  = ( Lambda * Alpha_corr_d * Lambda' + covn_dd); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;
						
						clear p3_temp, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;	
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	covn_score = covn_score~gg_temp; 
	clear covn_chol_dd, covn_dd;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the covn gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Alpha THE SATIATION PARAMETER OF THE MULTIPLE DISCRETE CONTINUOUS MODEL*****************************************************************/
 /***************AFFECTS THE JACOBIAN AND THE MEAN OF THE DISTRIBUTION*********************************************************************/
 alpha_score = {};
 for iAlpha_sat(1,rows(eqmatdel),1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+iAlpha_sat] == 0);
		alpha_score = alpha_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		xdel_grad = zeros(rows(eqmatdel),1); //A column vector
		xdel_grad[iAlpha_sat] = 1;
		xdel_grad = eqmatdel'*xdel_grad;
		
		w2_grad = (ones(nc,1) .*. xdel_grad)*~(dta[.,ivd])';
		
		j = 1;
		w_grad = {};	
		 do until j == nc+1;
			w_grad = w_grad~(sumc(w2_grad[(j-1)*nvardel+1:(j*nvardel),.]));			// beta*zeta deterministic
			j = j+1;
		endo; //w_grad is an nobs x nc matrix
		  
		a_grad = exp(w).*w_grad; //An nobs x nc matrix		
		if _alp0to1;
			a_grad = -(exp(w).*(w_grad))./(1+exp(w))^2; 		// a is 1-alpha
		endif;
		
		v_d = -a_grad .* ln((dta[.,flagchm]+f)./f); @An nobs x nc matrix@
		
		yd = zeros(nobs, nvar_mear);
		Vfd = v_d; @An nobs x nc matrix@
		
		if (_alp0to1 == 0);
			jac_grad1 = sumc((w_grad.*b)'); //An nobs x 1 matrix
			jac_grad2_top = sumc(((((dta[.,flagchm]+f).*(-w_grad))./exp(w)).*b)'); //nobs x 1 matrix
			jac_grad2_bottom = sumc((((dta[.,flagchm]+f)./exp(w)).*b)'); //nobs x 1 matrix
			jac_grad2 = jac_grad2_top ./ jac_grad2_bottom; //nobs x 1 matrix
			jac_grad = jac_grad1 + jac_grad2; //nobs x 1 matrix
		elseif (_alp0to1 == 1);
			jac_grad1 = sumc(((-exp(w)./(1+exp(w))).*w_grad.*b)'); //An nobs x 1 matrix
			jac_grad2_top = sumc(((dta[.,flagchm]+f).*w_grad.*exp(w).*b)'); //nobs x 1 matrix
			jac_grad2_bottom = sumc(((dta[.,flagchm]+f).*(1+exp(w)).*b)'); //nobs x 1 matrix
			jac_grad2 = jac_grad2_top ./ jac_grad2_bottom;//nobs x 1 vector
			jac_grad = jac_grad1 + jac_grad2; //nobs x 1 vector
		endif;
		clear jac_grad1, jac_grad2, jac_grad2_top, jac_grad2_bottom, v_d;
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;
						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;

						
						clear p3_temp, p3_temp1,p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = jac_grad[j] + p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		alpha_score = alpha_score~gg_temp;
		clear xdel_grad, w2_grad, w_grad, a_grad;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient - the satiation parameter@	
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO GAMMA THE SATIATION PARAMETER OF THE MULTIPLE DISCRETE CONTINUOUS MODEL*****************************************************************/
 /***************AFFECTS THE JACOBIAN AND THE MEAN OF THE DISTRIBUTION*********************************************************************/
 gamma_score = {};
 for iGamma(1,rows(eqmatgam),1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+iGamma] == 0);
		gamma_score = gamma_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		xgam_grad = zeros(rows(eqmatgam),1); //A column vector
		xgam_grad[iGamma] = 1;
		xgam_grad = eqmatgam'*xgam_grad;
		
		u2_grad = (ones(nc,1) .*. xgam_grad)*~(dta[.,ivg])';
		 
		 j = 1;
		 u_grad = {};	
		 do until j == nc+1;
			u_grad = u_grad~(sumc(u2_grad[(j-1)*nvargam+1:(j*nvargam),.]));			// beta*zeta deterministic
			j = j+1;
		endo; //u_grad is an nobs x nc matrix
		
		f_grad = f.*u_grad; //An nobs x nc matrix
		  
		v_d = (dta[.,flagchm].*u_grad.*a)./(dta[.,flagchm]+f);
		
		yd = zeros(nobs, nvar_mear);
		Vfd = v_d;
		 
		jac_grad1 = sumc(((-f_grad./(dta[.,flagchm]+f)).*b)'); //An nobs x 1 matrix
		jac_grad2_top = sumc(((f_grad./a).*b)'); //nobs x 1 matrix
		jac_grad2_bottom = sumc((((dta[.,flagchm]+f)./a).*b)'); //nobs x 1 matrix
		jac_grad2 = jac_grad2_top ./ jac_grad2_bottom; //nobs x 1 matrix
		jac_grad = jac_grad1 + jac_grad2; //nobs x 1 matrix
		clear jac_grad1, jac_grad2, jac_grad2_top, jac_grad2_bottom, v_d;
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;

						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;

						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = jac_grad[j] + p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		gamma_score = gamma_score~gg_temp;
		clear xgam_grad, u2_grad, u_grad, f_grad;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@	
		
 gradient = {};
 if(nvar_mear_ordl == 0);
	gradient = gradient~alpha_z_score~alpha_corr_score~delta_coeff_score~dmatrix_score~Psi_score~beta_score~lambda_score~alpha_score~gamma_score~covn_score;
 else; @Add gradients for the threshold parameters@
	gradient = gradient~alpha_z_score~alpha_corr_score~delta_coeff_score~dmatrix_score~Psi_score~lower_threshold_score~upper_threshold_score~beta_score~lambda_score~alpha_score~gamma_score~covn_score;
 endif;
 gradient_store = gradient;
 retp(gradient);
 endp;
 
 proc lprnorm1(x,dta);
 local wt,xbase, xdel,xsigm,xsigmm,xgam,xsd,xcov,v2,w2,u2,j,k, v,vv, Vf,w,u,a,f,b,m,mq,cqq,cq,sel,Jac,e,d, ww1;
 local covb,covn,ident,min1,p4,seedn,sq,app1,hj,zj,covj,corrj,p1,p2,p2_temp, ch,nch,mear_ch, ha,hb,mu,mu_final,omegacov,omegacorr,z1,count, dummy;
 local Alpha_coeff, Chol_Alpha_corr, delta_coeff, d_matrix_coeff, Psi_chol, Lambda_coeff, Lambda, Alpha_corr, D_matrix, Psi_matrix, AlphaW, z,y;
 local U_Y, Full_error, e1, e12, e21, e22,  Mmat, UY_Tild, Error_Tild, mean_one, err_one_var, mean_one_obs, mean_two, err_two_var, cov_one_two, mean_two_changed, err_two_changed, mean_two_final, err_two_varf, err_two_corrf, err_two_final; 
 local lower_threshold,upper_threshold, lower_threshold_matrix, upper_threshold_matrix, lower_threshold_mat, upper_threshold_mat;
 local g1,g2, rho_low_g1, rho_low_g2, rho_up_g1, rho_up_g2, corr_g1g2, S, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc, SS;
 local p3, p3_temp, p3_temp_low, p3_temp_up, rho_low_g3, rho_up_g3, g3, lower_threshold_append, upper_threshold_append, mear_nch;
 local mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc, Chol_alpha_corr_adjusted, Chol_alpha_corr_adjusted1, temp;
 local p3_temp1, p3_temp2;

if(nvar_mear_ordl == 0);
	Alpha_coeff        =  x[1:nvarml]; @structural equation parameters@
	Chol_Alpha_corr    =  upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])); @Creates a matrix@
	delta_coeff        =  x[nvarml+nCholOmega+1:nvarml+nCholOmega+nvar_mear]; @Means of measurement equation@
	d_matrix_coeff     =  x[nvarml+nCholOmega+nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear]; @Factor loadings@
	Psi_chol           =  upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1])); @ms eq. error corr.@
	xbase 			   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm]; //Baseline utility parameters
	Lambda_coeff 	   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent]; //Latent variable coefficient into the baseline utility
	xdel  			   = eqmatdel'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)]; //Converts the no. of alpha parameters to be estimated to the total no. of alternatives, nc
	xgam  			   = eqmatgam'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)];//same as above
	xcov  				= upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)])); //Get the cholesky factors
 elseif(nvar_mear_ordl > 0);
	Alpha_coeff       =  x[1:nvarml]; @structural equation parameters@
	Chol_Alpha_corr    =  upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])); @Creates a matrix@
	delta_coeff        =  x[nvarml+nCholOmega+1:nvarml+nCholOmega+nvar_mear]; @Means of measurement equation@
	d_matrix_coeff     =  x[nvarml+nCholOmega+nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear]; @Factor loadings@
	Psi_chol           =  upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1])); @ms eq. error corr.@
	lower_threshold 	   = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl]; @The lower threshold vector@
    upper_threshold    = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+nvar_mear_ordl]; @The lower threshold vector@ 	
	xbase 			   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm]; //Baseline utility parameters
	Lambda_coeff 	   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent]; //Latent variable coefficient into the baseline utility
	xdel  			   = eqmatdel'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)]; //Converts the no. of alpha parameters to be estimated to the total no. of alternatives, nc
	xgam  			   = eqmatgam'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)];//same as above
	xcov  			   = upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)])); //Get the cholesky factors
endif;

 Alpha_corr = Chol_Alpha_corr' * Chol_Alpha_corr; //Get the variance-covariance matrix of the latent variable
 D_matrix   = reshape(d_matrix_coeff,nvar_mear, nvar_latent); //reshape the factor loadings in nvar_mear x nvar_latent format
 Psi_matrix = Psi_chol' * Psi_chol; //Get the variance-covariance matrix of the indicators
 Lambda 	= reshape(Lambda_coeff, nc, nvar_latent); //  Reshape the Lambda_coeff into nc by nvar_latent format
 covn = xcov'*xcov; //xcov is a upper triangular matrix
 @covn is already a nc by nc matrix@
 //covn = zeros(1,nc)|(zeros(nc-1,1)~covn); //appending zero row on top and zero row on bottom
 
 if(nvar_mear_ordl > 0); @Next block of code assiging the lower and the upper threshold for each individual depending on their ordinal indicator response@
		lower_threshold_matrix = zeros(nobs, nvar_mear_ordl);
		upper_threshold_matrix = zeros(nobs, nvar_mear_ordl);
		
		lower_threshold_mat = ones(nobs,1) .*. lower_threshold'; @Converting the lower threshold into a row vector@
		upper_threshold_mat = ones(nobs,1) .*. upper_threshold'; @Converting the upper thershold into a row vector@
		
		lower_threshold_matrix[.,.] = (dta[.,ivgenyo] .==1) .* negative_infinity + (dta[.,ivgenyo].==2)   .* lower_threshold_mat + (dta[.,ivgenyo].==3) .* upper_threshold_mat;
		upper_threshold_matrix[.,.] = (dta[.,ivgenyo] .==1) .* lower_threshold_mat + (dta[.,ivgenyo].==2)   .* upper_threshold_mat + (dta[.,ivgenyo].==3) .* positive_infinity; 	
 endif;

 AlphaW = (ones(nvar_latent,1) .*. Alpha_coeff  )*~(dta[.,ivl])';
 z = {}; j = 1;	
 do until j > nvar_latent;
	z = z~(sumc(AlphaW[(j-1)*nvarml+1:(j*nvarml),.]));                // Z stores the latent variables value for each observation. nobs X nvar_latent. 1st col has z1, 2nd z2 and so on for all observations.
    j = j+1;
endo;
  
 @For each measurement equation, factor loading gets mult. by teh latent variable and summed up@
 y = ((D_matrix * z') + delta_coeff)'; // Y stores the Y variables value for each observation. nobs X nvar_mear. 1st col has Y1, 2nd Y2 and so on for all observations.

//multiply the variables with the appropriate betas for all the alternatives
 v2 = (ones(nc,1) .*. xbase)*~(dta[.,ivm])';
 w2 = (ones(nc,1) .*. xdel)*~(dta[.,ivd])'; //For alpha
 u2 = (ones(nc,1) .*. xgam)*~(dta[.,ivg])'; //For gamma

//Sum the deterministic portion of the utility, alpha and gamma
 j=1;
 v = {};
 w = {};
 u = {};
 do until j == nc+1;
   v = v~(sumc(v2[(j-1)*nvarm+1:(j*nvarm),.]));			// beta*zeta deterministic
   w = w~(sumc(w2[(j-1)*nvardel+1:(j*nvardel),.]));		// alpha
   u = u~(sumc(u2[(j-1)*nvargam+1:(j*nvargam),.]));		// gamma
   j = j+1;
 endo;
 //At the end of the loop, v, w and u are nobs x nc matrices

 vv = v + (Lambda * z')'; //Add latent variable into the baseline utility
 
 clear v2,w2,u2;
 
 @Convertion of alpha parameter@
 a = exp(w);		
 if _alp0to1;
   a = 1/(1+exp(w)); 		// a is 1-alpha
 endif;
 
 @Conversion of gamma parameter@
 f = exp(u);				// gamma
 b = dta[.,flagchm] .> 0;	// 1 if chosen, 0 if not //A nobs x nc matrix
 m = sumc(b');				// number of chosen alternatives  //an nobs x 1 column vector
 
 // Identifying alternative mq
 mq = b.* (seqa(1,1,nc))'; //Convert the 1's into the serial number of the alternatives
 mq = substute(mq,b.==0,nc+1); //Give a number greater than the total number of alternatives to the unchosen alternatives
 mq = minc(mq'); //Select the id of the first chosen alternative //mq is a nobs x 1 column vector
 
 //All the matrices in this equation are nobs x nc, must require the use of dot operator
 Vf = vv-a.*ln((dta[.,flagchm]+f)./f)-ln(dta[.,flagprcm]);	// deterministic component V //An nobs by nc matrix

 //Taking differences w/r to alternative mq
 cqq = reshape(((seqa(1,1,nc).*.ones(1,nobs)))', nobs*nc, 1 ); //cqq is a column of the seq of alternative numbers repeated nobs times
 cq = reshape(b, nobs*nc, 1 ); //Convert b into a column, where the seq is the participation indicator for 1st obs then for second observation and so on
 sel = cqq.*(cqq .!= (mq.*.ones(nc,1)));
 cq = reshape(selif(cq, cqq .== sel), nobs, nc-1); //cq is b arranged an nobs x (nc- 1) matrix//alternatives are 1 0 with 1 for selected and 0 for non-selected
 
 //Jacobian computation - not dividing by the price of mq, 
 //Correct if no price variation - need to correct if there is price variation
 Jac = (a.*b)./((dta[.,flagchm]+f));
 Jac = Jac./(dta[.,flagprcm]); 
 Jac = substute(Jac,b.==0,1); //
 e = (1/Jac).*b;  //nobs x nc matrix
 d = sumc((e'));//nobs x 1, the summation portion of the Jacobian
 Jac = (prodc((Jac'))).*d; //An nobs by 1 matrix
 
 U_Y = (y'|Vf')'; //concatenating the continuous indicator and the deterministinc portion of the utility
 e1   = ( D_matrix * Alpha_corr * D_matrix' + Psi_matrix ); @An nvar_mear x nvar_mear matrix@
 e12  = ( D_matrix * Alpha_corr * Lambda'); @nvar_mear x nc matrix@
 e21  = ( Lambda * Alpha_corr * D_matrix'); @nc x nvar_mar matrix@
 e22  = ( Lambda * Alpha_corr * Lambda' + covn); @nc x nc matrix@
	   
 @Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
 Full_error = (e1~e12);
 Full_error = Full_error | (e21~e22);
  
//Next two code blocks create the M matrix
 Mmat = zeros((nvar_mear+nc-1),(nvar_mear+nc));
 Mmat[1:nvar_mear,1:nvar_mear] = eye(nvar_mear);
 ident = eye(nc-1);
 min1 = -ones(nc-1,1);
 p4 = {};
 seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
 sq = seedn;
 
 j=1;//Begining of the loop through the individual
 do while j <= nobs;
	// Covariance ident - Creating the capital M matrix
	if mq[j]==nc;
		app1 = ident~min1;	
	elseif mq[j]==1;
		app1 = min1~ident;	  
	else;
		app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
	endif;
	
	Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

    UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
	Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
    
	// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
	if m[j] == 1;
		if(nvar_mear_cont>0);
			mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
			mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
			err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
			mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
			err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
			p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
		else;
			mean_two_final = UY_Tild;
			err_two_final = Error_Tild;
			
			p1 = 1;
		endif;
			
		if(nvar_mear_ordl > 1);
			p2 = 1; 
			for g1(1,nvar_mear_ordl-1,1);
				for g2(g1+1,nvar_mear_ordl,1);
					rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
					rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
					rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
					rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
					corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
					p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
					p2_temp = p2_temp.^(1/(nvar_mear_ordl));
					p2 = p2*p2_temp; @Contains the multiplication of the ordinal indictaor probabilities@
					
					clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
				endfor;
			endfor;
		else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
			p2 = 1;
		endif;
		
		if(nvar_mear_ordl > 0);
		   lower_threshold_append = {}; upper_threshold_append = {}; 
		   lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
		   upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
		   @This is a modified lower threshold append where the lower thresholds of the ordinals are appended with the upper thresholds of the non-chosen alternatives@
		   lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
		   upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
		   p3 = 1;
		   for g3(1,nvar_mear_ordl,1);
			S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
		    S[1,g3] = 1; @Put an 1 in the first row and g3th column@
		    S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
		    rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		    rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
		    mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
		    var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
			st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
		    mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
		    mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
		    corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
		    corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
			
			@The only difference between the mean_up_final and mean_low_final are the lower threshold values@
			if(nc == 2);
				p3_temp = cdfMvn(mean_up_final, corr_ordl_nc) - cdfMvn(mean_low_final, corr_ordl_nc);
				@This block will never be reached if the number of alternatives are greater than or equal to 3@
			else; @cdfmvna() can only be used when nc is greater than 2@
				{ p3_temp1,sq } = cdfmvna(mean_up_final',corr_ordl_nc,seedn);
				if (rho_low_g3[1] .== negative_infinity);
					p3_temp = p3_temp1;
				else;
					{ p3_temp2,sq } = cdfmvna(mean_low_final',corr_ordl_nc,seedn);
					p3_temp = p3_temp1 - p3_temp2;
				endif;
			endif;
			p3_temp = p3_temp.^(1/nvar_mear_ordl);
			p3 = p3*p3_temp;
		  	clear p3_temp, p3_temp1, p3_temp2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
		endfor;
		
		else; @If there are no ordinal indicators@
			mean_nc  = mean_two_final; 
			var_nc   = err_two_final; 
		
			st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
			mean_nc_final = (- mean_nc)./st_err_nc;
			corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
			corr_nc   = diagrv(corr_nc,ones(nc-1,1));
			
			if(nc-1 == 2);
				p3 = cdfMvn(mean_nc_final, corr_nc);
			else;
				{ p3,sq } = cdfmvna(mean_nc_final',corr_nc,seedn);	
			endif;
		endif; @End of calccualtion for p1, p2, p3@
		clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
	
	// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
	elseif m[j] == nc;
		if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
			S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
			S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
			S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
			mean_one = S*UY_Tild;
			mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
			err_one_var = S*Error_Tild*S';
		else; @No continuous indicators - only chosen alternatives@
			S = zeros((nc-1),(nvar_mear_ordl+nc-1));
			S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
			mean_one = S*UY_Tild;
			mean_one_obs = zeros(nc-1,1);
			err_one_var = S*Error_Tild*S';
		endif;
		
		p1 = Jac[j]*pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
		
		@Joint normal cdf needs to be calculated only for the ordinal indicators@
		if(nvar_mear_ordl > 0);
			mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
			SS = {};
			if(nvar_mear_cont>0);
				SS = SS|seqa(1,1,nvar_mear_cont);
			endif;
			SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1));
			cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
		
			@If more than one ordinal indicators - need to consider pair of them@
			if(nvar_mear_ordl > 1);	
				p2 = 1;
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
						p2_temp = p2_temp.^(1/(nvar_mear_ordl-1));
						p2 = p2*p2_temp; @Contains the multiplication of the ordinal indictaor probabilities@
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
					endfor;
				endfor;
			elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
				mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
			endif;
		else; @If no ordinal indicators@
			p2 = 1;	
		endif;
		@In this case p3 is always 1 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
		p3 = 1;
		
		clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
		// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
				k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
		
			p1 = Jac[j]*pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
		
			if(nvar_mear_ordl > 1);
				p2 = 1; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
						p2_temp = p2_temp.^(1/nvar_mear_ordl);
						p2 = p2*p2_temp; @Contains the multiplication of the ordinal indictaor probabilities@
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2 = 1;
			endif; @End of calculation of p2 - considering the pairs of the ordinals@
		
			if(nvar_mear_ordl > 0); @Sart of calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				@This is a new lower threshold, where the lower threshold of the ordinal indicators are appended with the upper threshold of the non-chosen alternatives@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3 = 1;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfMvn(mean_up_final, corr_ordl_nc) - cdfMvn(mean_low_final, corr_ordl_nc);
					else; @cdfmvna() can only be used when nc is greater than 2@
						{ p3_temp1,sq } = cdfmvna(mean_up_final',corr_ordl_nc,seedn);
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
						else;
							{ p3_temp2,sq } = cdfmvna(mean_low_final',corr_ordl_nc,seedn);
							p3_temp = p3_temp1 - p3_temp2;
						endif;
					endif;
					p3_temp = p3_temp .^(1/nvar_mear_ordl);
					p3 = p3*p3_temp;
					clear p3_temp, p3_temp1, p3_temp2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
				endfor;
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./st_err_nc;
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
				elseif(rows(nch)==2);
					p3 = cdfMvn(mean_nc_final, corr_nc);
				else;
					{ p3,sq } = cdfmvna(mean_nc_final',corr_nc,seedn);	
				endif;
			endif; @End of calccualtion for p3@
		clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
		endif; @End of check for how many alternatives have been consumed@
		
		p4 = p4|(p1*p2*p3); 
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	ww1=zeros(nobs,1);
	if p4 > ww1;
		z1 = ln(p4);
		post_obs = ones(nobs,1);
	else;
		z1=ln(p4-((p4.<=ww1).*(p4-0.0001)));
		post_obs = ((p4.<=ww1).*0)+(p4.>ww1);
	endif;
	retp(z1);
	endp;


proc lgdnorm1(x,dta);
 local wt,xbase, xdel,xsigm,xsigmm,xgam,xsd,xcov,v2,w2,u2,j,k, v,vv, Vf,w,u,a,f,b,m,mq,cqq,cq,sel,Jac,e,d, ww1;
 local covb,covn,ident,min1,p4,seedn,sq,app1,hj,zj,covj,corrj,p1,p2,p2_temp, ch,nch,mear_ch, ha,hb,mu,mu_final,omegacov,omegacorr,z1,count, dummy;
 local Alpha_coeff, Chol_Alpha_corr, delta_coeff, d_matrix_coeff, Psi_chol, Lambda_coeff, Lambda, Alpha_corr, D_matrix, Psi_matrix, AlphaW, z,y;
 local U_Y, Full_error, e1, e12, e21, e22,  Mmat, UY_Tild, Error_Tild, mean_one, err_one_var, mean_one_obs, mean_two, err_two_var, cov_one_two, mean_two_changed, err_two_changed, mean_two_final, err_two_varf, err_two_corrf, err_two_final; 
 local lower_threshold,upper_threshold, lower_threshold_matrix, upper_threshold_matrix, lower_threshold_mat, upper_threshold_mat;
 local g1,g2, rho_low_g1, rho_low_g2, rho_up_g1, rho_up_g2, corr_g1g2, S, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc, SS;
 local p3, p3_temp, p3_temp_low, p3_temp_up, rho_low_g3, rho_up_g3, g3, lower_threshold_append, upper_threshold_append, mear_nch;
 local mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc, e1_d, e12_d, e21_d, e22_d, Full_error_d;
 local Alpha_corr_d, Psi_matrix_d, covn_d, alpha_z_score, iAlpha, alpha_coeff_d, AlphaWd, zd, yd, Vfd, U_Yd, gg_temp, gg, p1_dd;
 local UY_Tild_d, Error_Tild_d, mean_one_d, mean_one_obs_d, err_one_var_d, mean_two_d, err_two_var_d, cov_one_two_d, mean_two_final_d, err_two_final_d, p1_d, p1_dm, p1_dr;
 local rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, corr_g1g2_d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p3_temp_up_d, p3_temp_low_d;
 local mean_ordl_nc_d, var_ordl_nc_d, st_err_ordl_nc_d, mean_low_final_d, mean_up_final_d, corr_ordl_nc_d, p3_temp_d ;
 local mean_nc_d, var_nc_d, st_err_nc_d, mean_nc_final_d, corr_nc_d,p3_d, p3_dd, p2_dd, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
 local gradient, alpha_corr_score, ia_corr, d_chol_alpha_corr, Alpha_corr_dd, shi_r_unq, ishi, delta_coeff_score, delta_coeff_d, iDelta, dmatrix_score, dmatrix_coeff_d, iDmat;
 local Psi_score, iPsi, Psi_chol_d, Psi_matrix_dd, lower_threshold_score, lower_threshold_d, lower_threshold_matrix_d, upper_threshold_score, upper_threshold_d, upper_threshold_matrix_d, iLower_th, iUpper_th, lower_threshold_mat_d, upper_threshold_mat_d;
 local lower_threshold_append_d, upper_threshold_append_d, rho_low_g3_d, rho_up_g3_d, beta_score, iBeta, xbase_d, v2_d, v_d, lambda_score, iLambda, lambda_coeff_d, lambda_mat_d;
 local covn_score, iCov, covn_chol_dd, covn_dd, alpha_score, iAlpha_sat, xdel_grad, w2_grad, w_grad, a_grad, jac_grad1, jac_grad2_top, jac_grad2_bottom, jac_grad2, jac_grad;
 local gamma_score, iGamma, xgam_grad, u2_grad, u_grad, f_grad, icheck, jcheck, d_chol_alpha_corr1, temp, Chol_Alpha_corr_adjusted, Chol_Alpha_corr_adjusted1;
 local p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2;
 
if(nvar_mear_ordl == 0);
	Alpha_coeff        =  x[1:nvarml]; @structural equation parameters@
	Chol_Alpha_corr    =  upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])); @Creates a matrix@
	delta_coeff        =  x[nvarml+nCholOmega+1:nvarml+nCholOmega+nvar_mear]; @Means of measurement equation@
	d_matrix_coeff     =  x[nvarml+nCholOmega+nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear]; @Factor loadings@
	Psi_chol           =  upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1])); @ms eq. error corr.@
	xbase 			   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm]; //Baseline utility parameters
	Lambda_coeff 	   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent]; //Latent variable coefficient into the baseline utility
	xdel  			   = eqmatdel'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)]; //Converts the no. of alpha parameters to be estimated to the total no. of alternatives, nc
	xgam  			   = eqmatgam'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)];//same as above
	xcov  				= upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)])); //Get the cholesky factors
 elseif(nvar_mear_ordl > 0);
	Alpha_coeff       =  x[1:nvarml]; @structural equation parameters@
	Chol_Alpha_corr    =  upmat(xpnd(x[nvarml+1:nvarml+nCholOmega])); @Creates a matrix@
	delta_coeff        =  x[nvarml+nCholOmega+1:nvarml+nCholOmega+nvar_mear]; @Means of measurement equation@
	d_matrix_coeff     =  x[nvarml+nCholOmega+nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear]; @Factor loadings@
	Psi_chol           =  upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1])); @ms eq. error corr.@
	lower_threshold 	   = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl]; @The lower threshold vector@
    upper_threshold    = x[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+1:nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+nvar_mear_ordl]; @The lower threshold vector@ 	
	xbase 			   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm]; //Baseline utility parameters
	Lambda_coeff 	   = x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent]; //Latent variable coefficient into the baseline utility
	xdel  			   = eqmatdel'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)]; //Converts the no. of alpha parameters to be estimated to the total no. of alternatives, nc
	xgam  			   = eqmatgam'*x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+1:nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)];//same as above
	xcov  			   = upmat(xpnd(x[nvarml+nCholOmega+nvar_mear+nvar_latent*nvar_mear+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+1:rows(x)])); //Get the cholesky factors
endif;
	
	
 
 Alpha_corr = Chol_Alpha_corr' * Chol_Alpha_corr; //Get the variance-covariance matrix of the latent variable
 D_matrix   = reshape(d_matrix_coeff,nvar_mear, nvar_latent); //reshape the factor loadings in nvar_mear x nvar_latent format
 Psi_matrix = Psi_chol' * Psi_chol; //Get the variance-covariance matrix of the indicators
 Lambda 	= reshape(Lambda_coeff, nc, nvar_latent); //  Reshape the Lambda_coeff into nc by nvar_latent format
 covn = xcov'*xcov; //xcov is a upper triangular matrix
 @covn is already a nc by nc matrix@
 //covn = zeros(1,nc)|(zeros(nc-1,1)~covn); //appending zero row on top and zero row on bottom
 
 Alpha_corr_d = zeros(nvar_latent,nvar_latent);
 Psi_matrix_d = zeros(nvar_mear,nvar_mear);
 covn_d      = zeros(nc,nc);
 
 if(nvar_mear_ordl > 0); @Next block of code assiging the lower and the upper threshold for each individual depending on their ordinal indicator response@
		lower_threshold_matrix = zeros(nobs, nvar_mear_ordl);
		upper_threshold_matrix = zeros(nobs, nvar_mear_ordl);
		
		lower_threshold_mat = ones(nobs,1) .*. lower_threshold'; @Converting the lower threshold into a row vector@
		upper_threshold_mat = ones(nobs,1) .*. upper_threshold'; @Converting the upper thershold into a row vector@
		
		lower_threshold_matrix[.,.] = (dta[.,ivgenyo] .==1) .* negative_infinity + (dta[.,ivgenyo].==2)   .* lower_threshold_mat + (dta[.,ivgenyo].==3) .* upper_threshold_mat;
		upper_threshold_matrix[.,.] = (dta[.,ivgenyo] .==1) .* lower_threshold_mat + (dta[.,ivgenyo].==2)   .* upper_threshold_mat + (dta[.,ivgenyo].==3) .* positive_infinity; 	
 endif;

 AlphaW = (ones(nvar_latent,1) .*. Alpha_coeff  )*~(dta[.,ivl])';
 z = {}; j = 1;	
 do until j > nvar_latent;
	z = z~(sumc(AlphaW[(j-1)*nvarml+1:(j*nvarml),.]));                // Z stores the latent variables value for each observation. nobs X nvar_latent. 1st col has z1, 2nd z2 and so on for all observations.
    j = j+1;
endo;
  
 @For each measurement equation, factor loading gets mult. by teh latent variable and summed up@
 y = ((D_matrix * z') + delta_coeff)'; // Y stores the Y variables value for each observation. nobs X nvar_mear. 1st col has Y1, 2nd Y2 and so on for all observations.

//multiply the variables with the appropriate betas for all the alternatives
 v2 = (ones(nc,1) .*. xbase)*~(dta[.,ivm])';
 w2 = (ones(nc,1) .*. xdel)*~(dta[.,ivd])'; //For alpha
 u2 = (ones(nc,1) .*. xgam)*~(dta[.,ivg])'; //For gamma

//Sum the deterministic portion of the utility, alpha and gamma
 j=1;
 v = {};
 w = {};
 u = {};
 do until j == nc+1;
   v = v~(sumc(v2[(j-1)*nvarm+1:(j*nvarm),.]));			// beta*zeta deterministic
   w = w~(sumc(w2[(j-1)*nvardel+1:(j*nvardel),.]));		// alpha
   u = u~(sumc(u2[(j-1)*nvargam+1:(j*nvargam),.]));		// gamma
   j = j+1;
 endo;
 //At the end of the loop, v, w and u are nobs x nc matrices

 vv = v + (Lambda * z')'; //Add latent variable into the baseline utility
 
 clear v2,w2,u2;
 
 @Convertion of alpha parameter@
 a = exp(w);		
 if _alp0to1;
   a = 1/(1+exp(w)); 		// a is 1-alpha
 endif;
 
 @Conversion of gamma parameter@
 f = exp(u);				// gamma
 b = dta[.,flagchm] .> 0;	// 1 if chosen, 0 if not //A nobs x nc matrix
 m = sumc(b');				// number of chosen alternatives  //an nobs x 1 column vector
 
 // Identifying alternative mq
 mq = b.* (seqa(1,1,nc))'; //Convert the 1's into the serial number of the alternatives
 mq = substute(mq,b.==0,nc+1); //Give a number greater than the total number of alternatives to the unchosen alternatives
 mq = minc(mq'); //Select the id of the first chosen alternative //mq is a nobs x 1 column vector
 
 //All the matrices in this equation are nobs x nc, must require the use of dot operator
 Vf = vv-a.*ln((dta[.,flagchm]+f)./f)-ln(dta[.,flagprcm]);	// deterministic component V //An nobs by nc matrix

 //Taking differences w/r to alternative mq
 cqq = reshape(((seqa(1,1,nc).*.ones(1,nobs)))', nobs*nc, 1 ); //cqq is a column of the seq of alternative numbers repeated nobs times
 cq = reshape(b, nobs*nc, 1 ); //Convert b into a column, where the seq is the participation indicator for 1st obs then for second observation and so on
 sel = cqq.*(cqq .!= (mq.*.ones(nc,1)));
 cq = reshape(selif(cq, cqq .== sel), nobs, nc-1); //cq is b arranged an nobs x (nc- 1) matrix//alternatives are 1 0 with 1 for selected and 0 for non-selected
 
 //Jacobian computation - not dividing by the price of mq, 
 //Correct if no price variation - need to correct if there is price variation
 Jac = (a.*b)./((dta[.,flagchm]+f));
 Jac = Jac./(dta[.,flagprcm]); 
 Jac = substute(Jac,b.==0,1); //
 e = (1/Jac).*b;  //nobs x nc matrix
 d = sumc((e'));//nobs x 1, the summation portion of the Jacobian
 Jac = (prodc((Jac'))).*d; //An nobs by 1 matrix
 
 U_Y = (y'|Vf')'; //concatenating the continuous indicator and the deterministinc portion of the utility
 e1   = ( D_matrix * Alpha_corr * D_matrix' + Psi_matrix ); @An nvar_mear x nvar_mear matrix@
 e12  = ( D_matrix * Alpha_corr * Lambda'); @nvar_mear x nc matrix@
 e21  = ( Lambda * Alpha_corr * D_matrix'); @nc x nvar_mar matrix@
 e22  = ( Lambda * Alpha_corr * Lambda' + covn); @nc x nc matrix@
	   
 @Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
 Full_error = (e1~e12);
 Full_error = Full_error | (e21~e22);
   
//Next two code blocks create the M matrix
 Mmat = zeros((nvar_mear+nc-1),(nvar_mear+nc));
 Mmat[1:nvar_mear,1:nvar_mear] = eye(nvar_mear);
 ident = eye(nc-1);
 min1 = -ones(nc-1,1);
 
  /***************************************************************************************************************************/
 /*Note: alpha_coeff is contained in the latent variable z, it will effect the means of the measurement equation i.e. y as well as
 the deterministic portion of the utility, i.e. Vf, but no error will be effected by the derivative, derivative need to be taken
 only w.r.t the mean of the joint normal pdf and the joint normal cdf*/
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Alpha_coeff*****************************************************************/
 
 alpha_z_score = {};
 for iAlpha(1,nvarml,1);
	 if(_max_active[iAlpha] == 0);
		 alpha_z_score = alpha_z_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 alpha_coeff_d = zeros(nvarml,1); //A column vector
		 alpha_coeff_d[iAlpha] = 1; //The derivative with respect to itself is 1
		 AlphaWd = (ones(nvar_latent,1) .*. alpha_coeff_d)*~(dta[.,ivl])';
		 
		 j = 1;
		 zd = {};	
		 do until j > nvar_latent;
			zd = zd~(sumc(AlphaWd[(j-1)*nvarml+1:(j*nvarml),.]));			
			j = j+1;
		 endo; //zd is a nobs x nvar_latent matrix
		
		yd = (D_matrix * zd')';		//yd is a nobs x nvar_mear matrix
		Vfd = (Lambda*zd')';  //Adding latent variable into the baseline utility
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					@new lower threshold, where lower thresholds of ordinal indicators are added with upper thresholds of the alternatives@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;
			
						clear p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, p3_temp, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					@Making a new lower threshold@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;
						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2,S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		alpha_z_score = alpha_z_score~gg_temp;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Alpha the cholesky factor of the error of the latent variable*****************************************************************/
 /***************ONLY AFFECTS THE ERRORS OF THE DISTRIBUTION*********************************************************************/
 
 alpha_corr_score = {};
 for ia_corr(1,nCholOmega,1);
	 if(_max_active[nvarml+ia_corr] == 0);
		 alpha_corr_score = alpha_corr_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 /*for icheck(1,rows(Chol_Corr_Map),1);
			for jcheck(1,cols(Chol_Corr_Map),1);
				if( (ia_corr eq Chol_Corr_Map[icheck,jcheck]) AND (Beta_corr_active[icheck,jcheck] eq 1) );
		   
					d_chol_alpha_corr1 = zeros(rows(Chol_Corr_Map),rows(Chol_Corr_Map));  
					temp = sumc(Chol_Alpha_corr_adjusted1[icheck,1:icheck-1]'.*Chol_Alpha_corr_adjusted1[icheck,1:icheck-1]');  
					d_chol_alpha_corr1[icheck,jcheck]= (1/sqrt(1+temp)) - ( (Chol_Alpha_corr_adjusted1[icheck,jcheck]^2)/ ( (1+temp)^(3/2) ) ); 
					d_chol_alpha_corr1[jcheck,icheck]= d_chol_alpha_corr1[icheck,jcheck];  
					d_chol_alpha_corr1[icheck,icheck] = (- Chol_Alpha_corr_adjusted1[icheck,jcheck])/ ( (1+temp)^(3/2) );  
                    clear temp;					   
				  endif;
			   endfor;
		endfor;
		d_chol_alpha_corr = upmat(d_chol_alpha_corr1); @Making it an upper triangular matrix@
		  
		Alpha_corr_dd = d_chol_alpha_corr'*Chol_Alpha_corr + Chol_Alpha_corr'*d_chol_alpha_corr;*/
		
		d_chol_alpha_corr = zeros(nCholOmega,1); //A column vector
		d_chol_alpha_corr[ia_corr] = 1;
		d_chol_alpha_corr = upmat(xpnd(d_chol_alpha_corr)); //The derivative with respect to itself is 1
		Alpha_corr_dd = d_chol_alpha_corr'*Chol_Alpha_corr + Chol_Alpha_corr'*d_chol_alpha_corr;
		 
		yd = zeros(nobs,nvar_mear);		//yd is a nobs x nvar_mear matrix
		Vfd = zeros(nobs,nc);  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( D_matrix * Alpha_corr_dd * D_matrix' + Psi_matrix_d ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( D_matrix * Alpha_corr_dd * Lambda'); @nvar_mear x nc matrix@
		e21_d  = ( Lambda * Alpha_corr_dd * D_matrix'); @nc x nvar_mar matrix@
		e22_d  = ( Lambda * Alpha_corr_dd * Lambda' + covn_d); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;
			
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/(nvar_mear_ordl))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;
						
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	alpha_corr_score = alpha_corr_score~gg_temp;
	clear d_chol_alpha_corr, Alpha_corr_dd;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Delta - The constants in the measurement equation*****************************************************************/
 /*****************************************Only affects the mean of the distribution**************************************************************************************/
 delta_coeff_score = {};
 for iDelta(1,nvar_mear,1); @nvar_mear contains the sum of the continuoous and the ordinal indicators@
	 if(_max_active[nvarml+nCholOmega+iDelta] == 0);
		delta_coeff_score = delta_coeff_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		delta_coeff_d = zeros(nvar_mear,1); //A column vector
		delta_coeff_d[iDelta] = 1; //The derivative with respect to itself is 1 @@
		
		yd = (ones(nobs,1) .*. delta_coeff_d');		//yd is a nobs x nvar_mear matrix
		Vfd = zeros(nobs,nc);  //Adding latent variable into the baseline utility
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators - no need to condition on the conitnuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;
			
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;
						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		delta_coeff_score = delta_coeff_score~gg_temp;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@

/****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO d_matrix, the factor loading*****************************************************************/
 /********************************AFFECTS BOTH THE MEAN AND THE ERRORS OF THE DISTRIBUTION*********************************************************************/ 
 dmatrix_score = {};
 for iDmat(1,nvar_mear*nvar_latent,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+iDmat] == 0);
		dmatrix_score = dmatrix_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		dmatrix_coeff_d = zeros(nvar_mear*nvar_latent,1); //A column vector
		dmatrix_coeff_d[iDmat] = 1;
		dmatrix_coeff_d = reshape(dmatrix_coeff_d, nvar_mear, nvar_latent);
		 
		yd = (dmatrix_coeff_d * z')'; @nobs x nvar_mear matrix@
		Vfd = zeros(nobs,nc);  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( dmatrix_coeff_d*Alpha_corr*D_matrix' + D_matrix*Alpha_corr*dmatrix_coeff_d' + Psi_matrix_d ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( dmatrix_coeff_d*Alpha_corr*Lambda'); @nvar_mear x nc matrix@
		e21_d  = ( Lambda*Alpha_corr*dmatrix_coeff_d'); @nc x nvar_mar matrix@
		e22_d  = ( Lambda*Alpha_corr_d*Lambda' + covn_d); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_dm = pdfgmean(mean_one_obs, mean_one,err_one_var); @Returns column vector@
					p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d) + p1_dr'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;
			
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2,S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_dm = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d)+ p1_dr'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_dm = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
			p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d)+p1_dr'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;	
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	dmatrix_score = dmatrix_score~gg_temp;
	clear dmatrix_coeff_d;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Psi_matrix the error of the measurement equation *****************************************************************/
 /***************ONLY AFFECTS THE ERRORS OF THE DISTRIBUTION*********************************************************************/
 Psi_score = {};
 for iPsi(1,nCholOmega1,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+iPsi] == 0);
		 Psi_score = Psi_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 Psi_chol_d = zeros(nCholOmega1,1); //A column vector
		 Psi_chol_d[iPsi] = 1;
		 Psi_chol_d = upmat(xpnd(Psi_chol_d)); //The derivative with respect to itself is 1
		 Psi_matrix_dd = Psi_chol_d'*Psi_chol + Psi_chol'*Psi_chol_d;
		 
		yd = zeros(nobs,nvar_mear);		//yd is a nobs x nvar_mear matrix
		Vfd = zeros(nobs,nc);  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( D_matrix * Alpha_corr_d * D_matrix' + Psi_matrix_dd ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( D_matrix * Alpha_corr_d * Lambda'); @nvar_mear x nc matrix@
		e21_d  = ( Lambda * Alpha_corr_d * D_matrix'); @nc x nvar_mar matrix@
		e22_d  = ( Lambda * Alpha_corr_d * Lambda' + covn_d); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;
						clear p3_temp, p3_temp1, p3_temp2,p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;	
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2,S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	Psi_score = Psi_score~gg_temp; 
	clear Psi_chol_d, Psi_matrix_dd;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO lower threshold*****************************************************************/
 if(nvar_mear_ordl > 0);
 lower_threshold_score = {};
 for iLower_th(1,nvar_mear_ordl,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+iLower_th] == 0);
		lower_threshold_score = lower_threshold_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		lower_threshold_d = zeros(nvar_mear_ordl,1); @row vector@   
		lower_threshold_d[iLower_th] = 1;
		
		lower_threshold_mat_d = ones(nobs,1) .*. lower_threshold_d';
		upper_threshold_mat_d = zeros(nobs,nvar_mear_ordl);
		
		lower_threshold_matrix_d = zeros(nobs, nvar_mear_ordl);
		upper_threshold_matrix_d = zeros(nobs, nvar_mear_ordl);
	
		lower_threshold_matrix_d = (dta[.,ivgenyo] .==1) .* negative_infinity_d + ((dta[.,ivgenyo].==2) )  .* lower_threshold_mat_d + (dta[.,ivgenyo].==3) .* upper_threshold_mat_d;
		upper_threshold_matrix_d = (dta[.,ivgenyo] .==1) .* lower_threshold_mat_d + ((dta[.,ivgenyo].==2) )  .* upper_threshold_mat_d + (dta[.,ivgenyo].==3) .* positive_infinity_d; 	
			
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
								
					p1_dd = 0; @Always zero - while taking derivatives with respect to the thresholds@
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
							rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
				
				@No check - since, already chcked for the presence of ordinal indicator@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
				
				lower_threshold_append_d = {}; upper_threshold_append_d = {};
				lower_threshold_append_d = lower_threshold_append_d|lower_threshold_matrix_d[j,.]'; @Making it a column@
				lower_threshold_append_d = lower_threshold_append_d|zeros(nc-1,1);
				upper_threshold_append_d = upper_threshold_append_d|upper_threshold_matrix_d[j,.]'|zeros(nc-1,1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
					rho_low_g3_d = S*lower_threshold_append_d;
					rho_up_g3_d = S*upper_threshold_append_d;
						
					mean_low_final_d = (rho_low_g3_d)./st_err_ordl_nc;
					mean_up_final_d = (rho_up_g3_d)./st_err_ordl_nc;
			
					if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;

			
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				@End of calculation of p1_dd, p2_dd and p3_dd for the first case@
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
				endif;
				
				p1_dd = 0;
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
				err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
				SS = {};
				if(nvar_mear_cont>0);
					SS = SS|seqa(1,1,nvar_mear_cont);
				endif;
				SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
				cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
				@If more than one ordinal indicators - need to consider pair of them@
				if(nvar_mear_ordl > 1);	
				p2_dd = 0;
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
						rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
						rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
						rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
						p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
					endfor;
				endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
			elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
				mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
				mean_low_final_d = lower_threshold_matrix_d[j,1]/sqrt(err_two_final);
				mean_up_final_d = upper_threshold_matrix_d[j,1]/sqrt(err_two_final);
				p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
			endif;
			
			@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
				k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
			
			p1_dd = 0;	@Always zero while taking derivative with respect to the ordinal indicators@
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
						rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
						rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
						rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		    
			@No check, since already checked for the presence of ordinal indicators@
			lower_threshold_append = {}; upper_threshold_append = {}; 
			lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
			upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
			lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
			upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
					
			lower_threshold_append_d = {}; upper_threshold_append_d = {};
			lower_threshold_append_d = lower_threshold_append_d|lower_threshold_matrix_d[j,.]'|zeros(rows(nch),1);
			upper_threshold_append_d = upper_threshold_append_d|upper_threshold_matrix_d[j,.]'|zeros((rows(nch)),1);
					
			p3_dd = 0;
			for g3(1,nvar_mear_ordl,1);
				S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
				S[1,g3] = 1; @Put an 1 in the first row and g3th column@
				S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
				rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
				rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
	   
				mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
				var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
				st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
				mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
				mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
				corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
				rho_low_g3_d = S*lower_threshold_append_d;
				rho_up_g3_d = S*upper_threshold_append_d;
				
				mean_low_final_d = (rho_low_g3_d)./st_err_ordl_nc;
				mean_up_final_d = (rho_up_g3_d)./st_err_ordl_nc;
			
				if((rows(nch)+1) == 2);
					p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
					p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
					p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
					p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
				else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
					{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
					if (rho_low_g3[1] .== negative_infinity);
						p3_temp = p3_temp1;
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
					else;
						{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						p3_temp = p3_temp1 - p3_temp2;
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
					endif;
				endif;

						
				clear p3_temp,p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
				clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
			endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	lower_threshold_score = lower_threshold_score~gg_temp;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO UPPER THRESHOLD*****************************************************************/
 upper_threshold_score = {};
 for iUpper_th(1,nvar_mear_ordl,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+nvar_mear_ordl+iUpper_th] == 0);
		upper_threshold_score = upper_threshold_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		upper_threshold_d = zeros(nvar_mear_ordl,1); @row vector@   
		upper_threshold_d[iUpper_th] = 1; @A column vector@
		
		lower_threshold_mat_d = zeros(nobs,nvar_mear_ordl);
		upper_threshold_mat_d = ones(nobs,1).*.upper_threshold_d';
		
		lower_threshold_matrix_d = zeros(nobs, nvar_mear_ordl);
		upper_threshold_matrix_d = zeros(nobs, nvar_mear_ordl);
	
		lower_threshold_matrix_d = (dta[.,ivgenyo] .==1) .* negative_infinity_d + ((dta[.,ivgenyo].==2) )  .* lower_threshold_mat_d + (dta[.,ivgenyo].==3) .* upper_threshold_mat_d;
		upper_threshold_matrix_d = (dta[.,ivgenyo] .==1) .* lower_threshold_mat_d + ((dta[.,ivgenyo].==2) )  .* upper_threshold_mat_d + (dta[.,ivgenyo].==3) .* positive_infinity_d; 	
			
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
								
					p1_dd = 0; @Always zero - while taking derivatives with respect to the thresholds@
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
							rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
				
				@No check - since, already chcked for the presence of ordinal indicator@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
				
				lower_threshold_append_d = {}; upper_threshold_append_d = {};
				lower_threshold_append_d = lower_threshold_append_d|lower_threshold_matrix_d[j,.]'|zeros(nc-1,1); @Making it a column@
				upper_threshold_append_d = upper_threshold_append_d|upper_threshold_matrix_d[j,.]'|zeros(nc-1,1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
					rho_low_g3_d = S*lower_threshold_append_d;
					rho_up_g3_d = S*upper_threshold_append_d;
						
					mean_low_final_d = (rho_low_g3_d)./st_err_ordl_nc;
					mean_up_final_d = (rho_up_g3_d)./st_err_ordl_nc;
			
					if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
						@This line is never touched with 3 or more alternatives@
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
					else; @cdfmvna() can only be used when nc is greater than 2@
						{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						if(rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
						else;
							{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
						endif;
					endif;

					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				@End of calculation of p1_dd, p2_dd and p3_dd for the first case@
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
				endif;
				
				p1_dd = 0;
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
				err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
				SS = {};
				if(nvar_mear_cont>0);
					SS = SS|seqa(1,1,nvar_mear_cont);
				endif;
				SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
				cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
				@If more than one ordinal indicators - need to consider pair of them@
				if(nvar_mear_ordl > 1);	
				p2_dd = 0;
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
						rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
						rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
						rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
						p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
					endfor;
				endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
			elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
				mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
				p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
				mean_low_final_d = lower_threshold_matrix_d[j,1]/sqrt(err_two_final);
				mean_up_final_d = upper_threshold_matrix_d[j,1]/sqrt(err_two_final);
				p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
			endif;
			
			@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
				k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
			
			p1_dd = 0;	@Always zero while taking derivative with respect to the ordinal indicators@
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = lower_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
						rho_low_g2d = lower_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
						rho_up_g1d = upper_threshold_matrix_d[j,g1]/sqrt(err_two_final[g1,g1]);
						rho_up_g2d = upper_threshold_matrix_d[j,g2]/sqrt(err_two_final[g2,g2]);
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
						p2_dd = p2_dd + (1/(nvar_mear_ordl))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		    
			@No check, since already checked for the presence of ordinal indicators@
			lower_threshold_append = {}; upper_threshold_append = {}; 
			lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
			upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
			lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
			upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
					
			lower_threshold_append_d = {}; upper_threshold_append_d = {};
			lower_threshold_append_d = lower_threshold_append_d|lower_threshold_matrix_d[j,.]'|zeros(rows(nch),1);
			upper_threshold_append_d = upper_threshold_append_d|upper_threshold_matrix_d[j,.]'|zeros(rows(nch),1);
					
			p3_dd = 0;
			for g3(1,nvar_mear_ordl,1);
				S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
				S[1,g3] = 1; @Put an 1 in the first row and g3th column@
				S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
				rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
				rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
	   
				mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
				var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
				st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
				mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
				mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
				corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
				rho_low_g3_d = S*lower_threshold_append_d;
				rho_up_g3_d = S*upper_threshold_append_d;
				
				mean_low_final_d = (rho_low_g3_d)./st_err_ordl_nc;
				mean_up_final_d = (rho_up_g3_d)./st_err_ordl_nc;
			
				if((rows(nch)+1) == 2);
					p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
					p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
					p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
					p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
				else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
					{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
					if (rho_low_g3[1] .== negative_infinity);
						p3_temp = p3_temp1;
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
					else;
						{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						p3_temp = p3_temp1 - p3_temp2;
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
					endif;
				endif;

						
				clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
				clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
			endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	upper_threshold_score = upper_threshold_score~gg_temp;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 endif; @END OF CHECK FOR THE PRESENSE OF ORDINAL INDICATORS@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO BETA*****************************************************************/
 beta_score = {};
 for iBeta(1,nvarm,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+iBeta] == 0);
		 beta_score = beta_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 xbase_d = zeros(nvarm,1); //A column vector
		 xbase_d[iBeta] = 1; //The derivative with respect to itself is 1
		 v2_d = (ones(nc,1) .*. xbase_d)*~(dta[.,ivm])';
		 
		 j = 1;
		 v_d = {};	
		 do until j > nc;
			v_d = v_d~(sumc(v2_d[(j-1)*nvarm+1:(j*nvarm),.]));			
			j = j+1;
		endo; //v_d is a nobs x nc matrix		
		
		yd = zeros(nobs,nvar_mear);		//yd is a nobs x nvar_mear matrix
		Vfd = v_d;  //Adding latent variable into the baseline utility
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;

						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;

						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		beta_score = beta_score~gg_temp;
		clear xbase_d, v2_d, v_d;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO lambda, THE COEFFICIENT OF THE LATENT VARIABLE INTO THE CHOICE MODEL UTILITY*****************************************************************/
 /********************************AFFECTS BOTH THE MEAN AND THE ERRORS OF THE DISTRIBUTION*********************************************************************/ 
 lambda_score = {};
 for iLambda(1,nc*nvar_latent,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+nvarm+iLambda] == 0);
		lambda_score = lambda_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		lambda_coeff_d = zeros(nc*nvar_latent,1); //A column vector
		lambda_coeff_d[iLambda] = 1;
		lambda_mat_d = reshape(lambda_coeff_d, nc, nvar_latent);
		 
		yd = zeros(nobs, nvar_mear); @nobs x nvar_mear matrix@
		Vfd = (lambda_mat_d*z')';  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( D_matrix*Alpha_corr_d*D_matrix' + Psi_matrix_d ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( D_matrix*Alpha_corr*lambda_mat_d'); @nvar_mear x nc matrix@
		e21_d  = ( lambda_mat_d*Alpha_corr*D_matrix'); @nc x nvar_mar matrix@
		e22_d  = ( lambda_mat_d*Alpha_corr*Lambda' + Lambda*Alpha_corr*lambda_mat_d' + covn_d); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_dm = pdfgmean(mean_one_obs, mean_one,err_one_var); @Returns column vector@
					p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d) + p1_dr'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;

			
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_dm = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d)+ p1_dr'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl - 1))* (1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_dm = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
			p1_dr = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_dm'*(mean_one_obs_d-mean_one_d)+p1_dr'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;
						
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	lambda_score = lambda_score~gg_temp;
	clear lambda_coeff_d, lambda_mat_d;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the lambda gradient@

/****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO covn THE ERROR OF THE CHOICE MODEL *****************************************************************/
 /***************ONLY AFFECTS THE ERRORS OF THE DISTRIBUTION*********************************************************************/
 covn_score = {};
 for iCov(1,ncov,1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+rows(eqmatgam)+iCov] == 0);
		 covn_score = covn_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		 covn_chol_dd = zeros(ncov,1); //A column vector
		 covn_chol_dd[iCov] = 1;
		 covn_chol_dd = upmat(xpnd(covn_chol_dd)); //The derivative with respect to itself is 1
		 //covn_dd = zeros(nc,nc);
		 //covn_dd[2:nc,2:nc] = covn_chol_dd'*xcov + xcov'*covn_chol_dd;
		 @Both covn_chol_dd and xcov are already nc by nc matrices@
		 covn_dd = covn_chol_dd'*xcov + xcov'*covn_chol_dd;
		 
		yd = zeros(nobs,nvar_mear);		//yd is a nobs x nvar_mear matrix
		Vfd = zeros(nobs,nc);  //Vfd is a nobs x nc matrix 
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		e1_d   = ( D_matrix * Alpha_corr_d * D_matrix' + Psi_matrix_d ); @An nvar_mear x nvar_mear matrix@
		e12_d  = ( D_matrix * Alpha_corr_d * Lambda'); @nvar_mear x nc matrix@
		e21_d  = ( Lambda * Alpha_corr_d * D_matrix'); @nc x nvar_mar matrix@
		e22_d  = ( Lambda * Alpha_corr_d * Lambda' + covn_dd); @nc x nc matrix@
	   
		@Full error is a (nvar_mear + nc) x (nvar_mear + nc) matrix@
		Full_error_d = (e1_d~e12_d);
		Full_error_d = Full_error_d | (e21_d~e22_d);
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
			Error_Tild_d = Mmat*Full_error_d*Mmat';
			
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					err_one_var_d = Error_Tild_d[1:nvar_mear_cont,1:nvar_mear_cont];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs - mean_one) - cov_one_two*inv(err_one_var)*(err_one_var_d)*inv(err_one_var)*(mean_one_obs-mean_one) + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d); @The derivatives of the errors are zero@ 
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + (cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two') - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					err_two_final_d = Error_Tild_d;
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d, corr_g1g2_d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						var_ordl_nc_d = S*err_two_final_d*S';
						
						st_err_ordl_nc_d = diag(var_ordl_nc_d);
						mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
						corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
				
							shi_r_unq = {};
							for ishi(1,rows(corr_ordl_nc_d)-1,1);
								shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
							endfor;
							
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq'); @Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:nc]*mean_up_final_d' + p3_temp_d1[(nc+1):cols(p3_temp_d1)]*shi_r_unq') - (p3_temp_d2[1:nc]*mean_low_final_d' + p3_temp_d2[(nc+1):cols(p3_temp_d2)]*shi_r_unq')); @Ignoring mean_low_final@
							endif;
						endif;
						
						clear p3_temp, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d, var_ordl_nc_d, st_err_ordl_nc_d, corr_ordl_nc_d, shi_r_unq, ishi;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = diag(var_nc); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					var_nc_d = err_two_final_d;
					
					st_err_nc_d = diag(var_nc_d);
					mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
					corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
					
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2]));
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
						endfor;
						
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d' + p3_d[nc:cols(p3_d)]*shi_r_unq');	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
				clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
					err_one_var_d = S*Error_Tild_d*S';
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
					err_one_var_d = S*Error_Tild_d*S';
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
					cov_one_two_d = Error_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one) - cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
							
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
							rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
							corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(lower_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					mean_up_final_d = (-mean_two_final_d*sqrt(err_two_final) - 0.5*(upper_threshold_matrix[j,1] - mean_two_final)*err_two_final_d/sqrt(err_two_final))/err_two_final;
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
			clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
		else;
			k = 1;
			ch = {};
			nch = {};
			do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
				if cq[j,k] == 1;
					ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
				else;
					nch = nch|(k+nvar_mear);
				endif;
					k = k+1;
			endo;
			mear_ch = {};
			mean_one_obs = {};
			mean_one_obs_d = {};
			if(nvar_mear_cont > 0);
				mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
				mean_one_obs = (dta[j,ivgenyc])';
				mean_one_obs_d = zeros(nvar_mear_cont,1);
			endif;
			mear_ch = mear_ch|ch;
			mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
			mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
			err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
			mean_one_d = UY_Tild_d[mear_ch];
			mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
			err_one_var_d = Error_Tild_d[mear_ch,mear_ch];
			
			p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
			p1_d = pdfgcov(mean_one_obs, mean_one, vech(err_one_var)); @Returns column vector@
			p1_dd = (1/p1)*(p1_d'*vech(err_one_var_d));
			
			mear_nch = {};
			if(nvar_mear_ordl > 0);
				mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
			endif;
			
			mear_nch = mear_nch|nch;
			mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
			err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
			cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
			mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
			err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
			mean_two_d = UY_Tild_d[mear_nch];
			err_two_var_d = Error_Tild_d[mear_nch,mear_nch];
			cov_one_two_d = Error_Tild_d[mear_nch,mear_ch];
			
			mean_two_final_d = mean_two_d + cov_one_two_d*inv(err_one_var)*(mean_one_obs-mean_one)-cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*(mean_one_obs-mean_one)+cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
			err_two_final_d = err_two_var_d - (cov_one_two_d*inv(err_one_var)*cov_one_two') + cov_one_two*inv(err_one_var)*err_one_var_d*inv(err_one_var)*cov_one_two' - cov_one_two*inv(err_one_var)*cov_one_two_d';
				
			if(nvar_mear_ordl > 1);
				p2_dd = 0; 
				for g1(1,nvar_mear_ordl-1,1);
					for g2(g1+1,nvar_mear_ordl,1);
						rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
						rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
						corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
						p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
						rho_low_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(lower_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_low_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(lower_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						rho_up_g1d = (-mean_two_final_d[g1]*sqrt(err_two_final[g1,g1])-0.5*(upper_threshold_matrix[j,g1]-mean_two_final[g1])*(err_two_final_d[g1,g1])/sqrt(err_two_final[g1,g1]))/(err_two_final[g1,g1]);
						rho_up_g2d = (-mean_two_final_d[g2]*sqrt(err_two_final[g2,g2])-0.5*(upper_threshold_matrix[j,g2]-mean_two_final[g2])*(err_two_final_d[g2,g2])/sqrt(err_two_final[g2,g2]))/(err_two_final[g2,g2]);
						corr_g1g2_d = ( ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ) * err_two_final_d[g1,g2] - (err_two_final[g1,g2]/2) * ( ( sqrt(err_two_final[g1,g1])/sqrt(err_two_final[g2,g2]) )*err_two_final_d[g2,g2] + ( sqrt(err_two_final[g2,g2])/sqrt(err_two_final[g1,g1]) )*err_two_final_d[g1,g1] ) ) / ( err_two_final[g1,g1] * err_two_final[g2,g2]); @CHECK@
							
						p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
						p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
						p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
						p2_temp_11d = rho_up_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_22d = rho_up_g1d|rho_low_g2d|corr_g1g2_d;
						p2_temp_33d = rho_low_g1d|rho_up_g2d|corr_g1g2_d;
						p2_temp_44d = rho_low_g1d|rho_low_g2d|corr_g1g2_d;
							
						p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
						clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, corr_g1g2_d; 
						clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
					endfor;
				endfor;
			else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
				p2_dd = 0;
			endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
			if(nvar_mear_ordl > 0); @Calculation for p3@
				lower_threshold_append = {}; upper_threshold_append = {}; 
				lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
				upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
				lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
				upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
				p3_dd = 0;
				for g3(1,nvar_mear_ordl,1);
					S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
					S[1,g3] = 1; @Put an 1 in the first row and g3th column@
					S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
					rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
					rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
					mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
					var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
					st_err_ordl_nc = diag(var_ordl_nc); @Standard error of the conditional distribution@
					mean_low_final = (rho_low_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					mean_up_final  = (rho_up_g3 - mean_ordl_nc)./sqrt(st_err_ordl_nc);
					corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
					mean_ordl_nc_d = S*mean_two_final_d;
					var_ordl_nc_d = S*err_two_final_d*S';
					
					st_err_ordl_nc_d = diag(var_ordl_nc_d);
				    mean_low_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_low_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					mean_up_final_d = ( - sqrt(st_err_ordl_nc') .* mean_ordl_nc_d' - 0.5*(rho_up_g3 - mean_ordl_nc)' .* st_err_ordl_nc_d' ./ sqrt(st_err_ordl_nc') ) ./ (st_err_ordl_nc'); @A Row vector@
					corr_ordl_nc_d  = ( (var_ordl_nc_d./sqrt(st_err_ordl_nc))' ./ sqrt(st_err_ordl_nc) ) - 0.5 * ( (var_ordl_nc ./(st_err_ordl_nc^(3/2)) .* st_err_ordl_nc_d)' ./(st_err_ordl_nc^(1/2)) + ((var_ordl_nc ./(st_err_ordl_nc^(1/2)))' ./(st_err_ordl_nc^(3/2))) .* st_err_ordl_nc_d ) ;	
			
					if((rows(nch)+1) == 2);
						p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
						p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
						p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
						p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d'*(mean_up_final_d'|corr_ordl_nc_d[1,2]) - p3_temp_low_d'*(mean_low_final_d'|corr_ordl_nc_d[1,2]));
					else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
						{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
						
						shi_r_unq = {};
						for ishi(1,rows(corr_ordl_nc_d)-1,1);
							shi_r_unq = shi_r_unq ~ corr_ordl_nc_d[ishi,ishi+1:cols(corr_ordl_nc_d)]; @A row vector@
						endfor;
						if (rho_low_g3[1] .== negative_infinity);
							p3_temp = p3_temp1;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq'); @The derivative of the mean_low_final_d is ignored@
						else;
							{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							p3_temp = p3_temp1 - p3_temp2;
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*((p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d' + p3_temp_d1[(rows(nch)+2):cols(p3_temp_d1)]*shi_r_unq')-(p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d' + p3_temp_d2[(rows(nch)+2):cols(p3_temp_d2)]*shi_r_unq')); @The derivative of the mean_low_final_d is ignored@
						endif;					
					endif;	
					clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
					clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d,var_ordl_nc_d, st_err_ordl_nc_d ;
					clear corr_ordl_nc_d, shi_r_unq, ishi;
				endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
			else; @If there are no ordinal indicators@
				mean_nc  = mean_two_final; 
				var_nc   = err_two_final; 
		
				st_err_nc = diag(var_nc); @Standard error of the conditional distribution@
				mean_nc_final = (- mean_nc)./sqrt(st_err_nc);
				corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
				corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
				mean_nc_d = mean_two_final_d;
				var_nc_d = err_two_final_d;
				
				st_err_nc_d = diag(var_nc_d);
				mean_nc_final_d = (sqrt(st_err_nc') .* (-mean_nc_d)' + 0.5*(mean_nc)' .* st_err_nc_d' ./ sqrt(st_err_nc')) ./ (st_err_nc'); @A row vector@
				corr_nc_d      = ( (var_nc_d./sqrt(st_err_nc))' ./ sqrt(st_err_nc) ) - 0.5 * ( ((var_nc ./(st_err_nc^(3/2))) .* st_err_nc_d )' ./(st_err_nc^(1/2))   + ((var_nc ./(st_err_nc^(1/2)) )' ./(st_err_nc^(3/2))) .* st_err_nc_d ) ;
			
				if(rows(nch) == 1);
					p3 = cdfn(mean_nc_final);
					p3_d = pdfn(mean_nc_final);
					p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
				elseif(rows(nch)==2);
					p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
					p3_dd = (1/p3)*(p3_d'*(mean_nc_final_d'|corr_nc_d[1,2])); @Returns column vector@
				else;
					{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
					
					shi_r_unq = {};
					for ishi(1,rows(corr_nc_d)-1,1);
						shi_r_unq = shi_r_unq ~ corr_nc_d[ishi,ishi+1:cols(corr_nc_d)]; @A row vector@
					endfor;
					
					p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d' + p3_d[(rows(nch)+1):cols(p3_d)]*shi_r_unq');
				endif;
			endif; @End of calccualtion for p3_dd for the last case@
			clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
			clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			clear var_nc_d, st_err_nc_d, shi_r_unq, ishi, corr_nc_d;
		endif; @End of check for how many alternatives have been consumed@
		
		gg = p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
		gg_temp = gg_temp|gg; @concatenating for each individual@
		
		seedn = sq;
		j = j+1;
	endo; @End of looping for individual@

	gg_temp = gg_temp .* post_obs;
	covn_score = covn_score~gg_temp; 
	clear covn_chol_dd, covn_dd;
 endif; @End of check whether the parameter is active@
 endfor; @End of loop through the covn gradient@
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO Alpha THE SATIATION PARAMETER OF THE MULTIPLE DISCRETE CONTINUOUS MODEL*****************************************************************/
 /***************AFFECTS THE JACOBIAN AND THE MEAN OF THE DISTRIBUTION*********************************************************************/
 alpha_score = {};
 for iAlpha_sat(1,rows(eqmatdel),1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+iAlpha_sat] == 0);
		alpha_score = alpha_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		xdel_grad = zeros(rows(eqmatdel),1); //A column vector
		xdel_grad[iAlpha_sat] = 1;
		xdel_grad = eqmatdel'*xdel_grad;
		
		w2_grad = (ones(nc,1) .*. xdel_grad)*~(dta[.,ivd])';
		
		j = 1;
		w_grad = {};	
		 do until j == nc+1;
			w_grad = w_grad~(sumc(w2_grad[(j-1)*nvardel+1:(j*nvardel),.]));			// beta*zeta deterministic
			j = j+1;
		endo; //w_grad is an nobs x nc matrix
		  
		a_grad = exp(w).*w_grad; //An nobs x nc matrix		
		if _alp0to1;
			a_grad = -(exp(w).*(w_grad))./(1+exp(w))^2; 		// a is 1-alpha
		endif;
		
		v_d = -a_grad .* ln((dta[.,flagchm]+f)./f); @An nobs x nc matrix@
		
		yd = zeros(nobs, nvar_mear);
		Vfd = v_d; @An nobs x nc matrix@
		
		if (_alp0to1 == 0);
			jac_grad1 = sumc((w_grad.*b)'); //An nobs x 1 matrix
			jac_grad2_top = sumc(((((dta[.,flagchm]+f).*(-w_grad))./exp(w)).*b)'); //nobs x 1 matrix
			jac_grad2_bottom = sumc((((dta[.,flagchm]+f)./exp(w)).*b)'); //nobs x 1 matrix
			jac_grad2 = jac_grad2_top ./ jac_grad2_bottom; //nobs x 1 matrix
			jac_grad = jac_grad1 + jac_grad2; //nobs x 1 matrix
		elseif (_alp0to1 == 1);
			jac_grad1 = sumc(((-exp(w)./(1+exp(w))).*w_grad.*b)'); //An nobs x 1 matrix
			jac_grad2_top = sumc(((dta[.,flagchm]+f).*w_grad.*exp(w).*b)'); //nobs x 1 matrix
			jac_grad2_bottom = sumc(((dta[.,flagchm]+f).*(1+exp(w)).*b)'); //nobs x 1 matrix
			jac_grad2 = jac_grad2_top ./ jac_grad2_bottom;//nobs x 1 vector
			jac_grad = jac_grad1 + jac_grad2; //nobs x 1 vector
		endif;
		clear jac_grad1, jac_grad2, jac_grad2_top, jac_grad2_bottom, v_d;
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;
						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;

						
						clear p3_temp, p3_temp1,p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = jac_grad[j] + p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
		
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@

		gg_temp = gg_temp .* post_obs;
		alpha_score = alpha_score~gg_temp;
		clear xdel_grad, w2_grad, w_grad, a_grad;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient - the satiation parameter@	
 
 /****************************************************************************************************************************/
 /*****************************GRADIENT WITH RESPECT TO GAMMA THE SATIATION PARAMETER OF THE MULTIPLE DISCRETE CONTINUOUS MODEL*****************************************************************/
 /***************AFFECTS THE JACOBIAN AND THE MEAN OF THE DISTRIBUTION*********************************************************************/
 gamma_score = {};
 for iGamma(1,rows(eqmatgam),1);
	 if(_max_active[nvarml+nCholOmega+nvar_mear+nvar_mear*nvar_latent+nCholOmega1+2*nvar_mear_ordl+nvarm+nc*nvar_latent+rows(eqmatdel)+iGamma] == 0);
		gamma_score = gamma_score ~ zeros(nobs,1); //If the coefficient is fixed, fill derivative with 0 for all observations
	 else;
		xgam_grad = zeros(rows(eqmatgam),1); //A column vector
		xgam_grad[iGamma] = 1;
		xgam_grad = eqmatgam'*xgam_grad;
		
		u2_grad = (ones(nc,1) .*. xgam_grad)*~(dta[.,ivg])';
		 
		 j = 1;
		 u_grad = {};	
		 do until j == nc+1;
			u_grad = u_grad~(sumc(u2_grad[(j-1)*nvargam+1:(j*nvargam),.]));			// beta*zeta deterministic
			j = j+1;
		endo; //u_grad is an nobs x nc matrix
		
		f_grad = f.*u_grad; //An nobs x nc matrix
		  
		v_d = (dta[.,flagchm].*u_grad.*a)./(dta[.,flagchm]+f);
		
		yd = zeros(nobs, nvar_mear);
		Vfd = v_d;
		 
		jac_grad1 = sumc(((-f_grad./(dta[.,flagchm]+f)).*b)'); //An nobs x 1 matrix
		jac_grad2_top = sumc(((f_grad./a).*b)'); //nobs x 1 matrix
		jac_grad2_bottom = sumc((((dta[.,flagchm]+f)./a).*b)'); //nobs x 1 matrix
		jac_grad2 = jac_grad2_top ./ jac_grad2_bottom; //nobs x 1 matrix
		jac_grad = jac_grad1 + jac_grad2; //nobs x 1 matrix
		clear jac_grad1, jac_grad2, jac_grad2_top, jac_grad2_bottom, v_d;
		
		U_Yd = (yd'|Vfd')';//Concatenating the indicators and the deterministic portion of the utility, A nobsx(nvar_mear+nc)
		
		//Next two code blocks create the M matrix
		seedn = seednext; //A different seed is used for each individual, across iterations the seed remain the same
		sq = seedn;
		gg_temp = {};//The score for each individual is concatenated in gg_temp 
 
		j=1;//Begining of the loop through the individual
		do while j <= nobs;
			gg = 0;
			// Covariance ident - Creating the capital M matrix
			if mq[j]==nc;
				app1 = ident~min1;	
			elseif mq[j]==1;
				app1 = min1~ident;	  
			else;
				app1 = ident[.,1:mq[j]-1]~min1~ident[.,mq[j]:nc-1];
			endif;
	
			Mmat[nvar_mear+1:nvar_mear+nc-1,nvar_mear+1:nvar_mear+nc] = app1;

			UY_Tild = Mmat*U_Y[j,.]'; //Taking the difference for the deterministic portion of the utility
			Error_Tild = Mmat*(Full_error)*Mmat'; //covn is nc x nc, finally covj is initially nc x nc //After multiplying by app1 covj will be nc-1 x nc-1
			
			UY_Tild_d = Mmat*U_Yd[j,.]'; @The error derivative is zero@
    
		// Case 1: only corner solutions - only one alternative is chosen - Joint normal pdf for continuous indicators & only joint normal cdf needs to be calculated for non-chosen alternatives
			if m[j] == 1;
				if(nvar_mear_cont>0);
					mean_one = UY_Tild[1:nvar_mear_cont]; @The measuremnet equation mean@
					mean_one_obs = (dta[j,ivgenyc])'; @Reported values of the continuous indicators@ @Making it a column vector@
					err_one_var = Error_Tild[1:nvar_mear_cont,1:nvar_mear_cont]; @Variance-covariance matrix of the continuous indicators@
		
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @Mean of the non-chosen alternatives@
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @variance-covariance matrix of the non-chosen alternatives@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1,1:nvar_mear_cont]; //(nc-1) x nvar_mear matrix
		
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
			
					p1 = pdfmvn(mean_one_obs,mean_one,err_one_var); @joint normal pdf calculation of the continuous indicators@
					
					mean_one_d = UY_Tild_d[1:nvar_mear_cont];
					mean_one_obs_d = zeros(nvar_mear_cont,1); @Always the derivative is zero@
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl+nc-1]; @The ordinal indicators and the rest of the alternatives@
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d - mean_one_d); @The derivatives of the errors are zero@ 
					
					p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
					p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
				else; @If there are no continuous indicators@
					mean_two_final = UY_Tild;
					err_two_final = Error_Tild;
					
					mean_two_final_d = UY_Tild_d; @Contain the ordinal indicators and the non-chosen alternatives@
					p1_dd = 0; @No conitnuous indicataors, so..@
				endif; @End of calculation for p1_dd for the first case@
			
				if(nvar_mear_ordl > 1); @If more than 1 ordinal indicators, consider the pairs of them@
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*(p2_temp_1d'*p2_temp_11d - p2_temp_2d'*p2_temp_22d - p2_temp_3d'*p2_temp_33d + p2_temp_4d'*p2_temp_44d);
							
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp, rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d;
							clear p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation for p2_dd for the first case@
		
				if(nvar_mear_ordl > 0); @Consider the combination of each of the ordinal indicators and the non-chosen alternatives@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(nc-1,1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(nc-1,1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros(nc,nvar_mear_ordl+nc-1);	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:nc,nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones(nc,1));
						
						mean_ordl_nc_d = S*mean_two_final_d;
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if(nc == 2); @no. of non-chosen are nc-1 plus one ordinal indicator@
							@This line is never touched with 3 or more alternatives@
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2]) - cdfBvn(mean_low_final[1], mean_low_final[2],corr_ordl_nc[1,2]);
							
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vector@
							
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @cdfmvna() can only be used when nc is greater than 2@
							{ p3_temp1,p3_temp_d1,sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if(rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d);	@Ignoring mean_low_final@
							else;
								{ p3_temp2,p3_temp_d2,sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:nc]*mean_up_final_d - p3_temp_d2[1:nc]*mean_low_final_d); @Ignoring mean_low_final@
							endif;
						endif;

						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_up_d, p3_temp_low_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
		
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@	
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(nc-1,1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivatives for the errors are zero@
			
					if((nc-1) == 2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2],corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]); @Returns a column vector@
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d);
					else;
						{ p3,p3_d,sq } = pdfmvna(mean_nc_final',corr_nc,seedn); @p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:(nc-1)]*mean_nc_final_d);	
					endif;
				endif; @End of calccualtion for p3_dd for the first case@
				
				clear mean_one, mean_one_obs, mean_two, err_one_var, err_two_var, cov_one_two, err_two_final, mean_two_final,mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc ;		
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d; 
			
			// Case 2: only interior soultions - all the available alternatives are chosen - only a joint normal pdf needs to be calculated
			elseif m[j] == nc;
				if(nvar_mear_cont > 0); @Take both the continuous indicators and the chosen alternatives@
					S = zeros((nvar_mear_cont+nc-1),(nvar_mear_cont+nvar_mear_ordl+nc-1)); @S is a transformation matrix@
					S[1:nvar_mear_cont,1:nvar_mear_cont] = eye(nvar_mear_cont);
					S[nvar_mear_cont+1:nvar_mear_cont+nc-1,nvar_mear_cont+nvar_mear_ordl+1:nvar_mear_cont+nvar_mear_ordl+nc-1]=eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = (dta[j,ivgenyc])'|zeros((nc-1),1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d;
					mean_one_obs_d = zeros((nvar_mear_cont+nc-1),1); @The derivative is always zero@ @The derivatives of the errors are zero@
				else; @No continuous indicators - only chosen alternatives@
					S = zeros((nc-1),(nvar_mear_ordl+nc-1));
					S[1:(nc-1),nvar_mear_ordl+1:nvar_mear_ordl+nc-1] = eye(nc-1);
					mean_one = S*UY_Tild;
					mean_one_obs = zeros(nc-1,1);
					err_one_var = S*Error_Tild*S';
					
					mean_one_d = S*UY_Tild_d; @The derivatives of the errors are zero@
					mean_one_obs_d = zeros(nc-1,1);
				endif;
		
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var); @Calculation of the joint normal pdf@
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns a column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d - mean_one_d)); @End of calculation of p1_dd@ 
				
				@Joint normal cdf needs to be calculated only for the ordinal indicators@
				if(nvar_mear_ordl > 0);
					mean_two = UY_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					err_two_var = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
					
					mean_two_d = UY_Tild_d[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl];
			
					SS = {};
					if(nvar_mear_cont>0);
						SS = SS|seqa(1,1,nvar_mear_cont);
					endif;
					SS	= SS|seqa((nvar_mear_cont+nvar_mear_ordl+1),1,(nc-1)); @covariance row numbers@
					cov_one_two = Error_Tild[nvar_mear_cont+1:nvar_mear_cont+nvar_mear_ordl,SS];
			
					mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
					err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
					
					mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
					
					@If more than one ordinal indicators - need to consider pair of them@
					if(nvar_mear_ordl > 1);	
					p2_dd = 0;
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/(nvar_mear_ordl-1))*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d;
						endfor;
					endfor; @End of calculation of p2_dd if there are more than one ordinal indicators@
				elseif(nvar_mear_ordl == 1); @If one - no need to consider the pairs of the ordinals@
					mean_low_final = (lower_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					mean_up_final = (upper_threshold_matrix[j,1] - mean_two_final)/ sqrt(err_two_final);
					p2 = cdfn(mean_up_final) - cdfn(mean_low_final);
					
					mean_low_final_d = -mean_two_final_d/sqrt(err_two_final);
					mean_up_final_d = -mean_two_final_d/sqrt(err_two_final);
					p2_dd = (1/p2)*(pdfn(mean_up_final) .* mean_up_final_d - pdfn(mean_low_final)*mean_low_final_d);	
				endif;
			else; @If no ordinal indicators@
				p2_dd = 0;	
			endif; @End of calculation for p2_dd@
			
				@In this case p3_dd is always 0 -  Since all the alternatives are chosen and there are no non-chosen alterantives@
			p3_dd = 0;
		
				clear S, mean_one, mean_one_obs, err_one_var, mean_two, err_two_var, SS, cov_one_two, mean_two_final, err_two_final, mean_low_final, mean_up_final;
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_low_final_d, mean_up_final_d; 
			// Case 3: corner and interior solutions - both the joint normal pdf and joint normal cdf need to be calculated
			else;
				k = 1;
				ch = {};
				nch = {};
				do while k <= nc-1; //for a single individual looping through (nc-1) alternatives, the left one is mq
					if cq[j,k] == 1;
						ch = ch|(k+nvar_mear); @nvar_mear is the sum of the nvar_mear_cont and nvar_mear_ordl@
					else;
						nch = nch|(k+nvar_mear);
					endif;
					k = k+1;
				endo;
				mear_ch = {};
				mean_one_obs = {};
				mean_one_obs_d = {};
				if(nvar_mear_cont > 0);
					mear_ch = mear_ch|seqa(1,1,nvar_mear_cont);
					mean_one_obs = (dta[j,ivgenyc])';
					mean_one_obs_d = zeros(nvar_mear_cont,1);
				endif;
				mear_ch = mear_ch|ch;
				mean_one = UY_Tild[mear_ch]; //Contains the continuous indicators and deterministic portion of the utility for the chosen alternatives without mq in a column vector 
				mean_one_obs = mean_one_obs|(zeros(rows(ch),1)); @Reported values of the continuous indicators@
				err_one_var = Error_Tild[mear_ch,mear_ch]; @Variance-covariance matrix of the continuous indicators and the chosen alternatives@
				
				mean_one_d = UY_Tild_d[mear_ch];
				mean_one_obs_d = mean_one_obs_d|zeros(rows(ch),1);
				
				p1 = pdfmvn(mean_one_obs, mean_one, err_one_var);//The joint normal pdf of the chosen alternatives without mq
				p1_d = pdfgmean(mean_one_obs, mean_one, err_one_var); @Returns column vector@
				p1_dd = (1/p1)*(p1_d'*(mean_one_obs_d-mean_one_d));
			
				mear_nch = {};
				if(nvar_mear_ordl > 0);
					mear_nch = mear_nch|seqa((nvar_mear_cont+1),1,(nvar_mear_ordl));
				endif;
			
				mear_nch = mear_nch|nch;
				mean_two = UY_Tild[mear_nch]; //Conatins the deterministic portion of the utility for the non-chosen alternatives in a column vector
				err_two_var = Error_Tild[mear_nch,mear_nch]; @variance-covariance matrix of the non-chosen alternatives@
				cov_one_two = Error_Tild[mear_nch,mear_ch]; 
			
				mean_two_final = mean_two + cov_one_two * inv(err_one_var) * (mean_one_obs - mean_one); @Conditional mean of the non-chosen alternatives@
				err_two_final = err_two_var - (cov_one_two * inv(err_one_var) * cov_one_two');  @conditional variance-covariance of the non-chsen alternatives@
				
				mean_two_d = UY_Tild_d[mear_nch];
				mean_two_final_d = mean_two_d + cov_one_two*inv(err_one_var)*(mean_one_obs_d-mean_one_d);
				
				if(nvar_mear_ordl > 1);
					p2_dd = 0; 
					for g1(1,nvar_mear_ordl-1,1);
						for g2(g1+1,nvar_mear_ordl,1);
							rho_low_g1 =  (lower_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_low_g2 =  (lower_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							rho_up_g1 =   (upper_threshold_matrix[j,g1] - mean_two_final[g1] ) / sqrt(err_two_final[g1,g1]);
							rho_up_g2 =   (upper_threshold_matrix[j,g2] - mean_two_final[g2] ) / sqrt(err_two_final[g2,g2]);
							corr_g1g2   =  err_two_final[g1,g2] / ( sqrt(err_two_final[g1,g1]) * sqrt(err_two_final[g2,g2]) ); @Corr(g1,g2) = cov(g1,g2)/sqrt(var(g1)* var(g2))@
	           
							p2_temp = cdfbvn(rho_up_g1,rho_up_g2,corr_g1g2) - cdfbvn(rho_up_g1,rho_low_g2,corr_g1g2) - cdfbvn(rho_low_g1,rho_up_g2,corr_g1g2) + cdfbvn(rho_low_g1,rho_low_g2,corr_g1g2);
							
							rho_low_g1d = -mean_two_final_d[g1]/sqrt(err_two_final[g1,g1]); @Derivatives for the error and the threshold are zero@
							rho_low_g2d = -mean_two_final_d[g2]/sqrt(err_two_final[g2,g2]); @Derivatives for the errors and the thresholds are zero@
							rho_up_g1d = rho_low_g1d;
							rho_up_g2d = rho_low_g2d;
							
							p2_temp_1d = cdfbvn_grad(rho_up_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_2d = cdfbvn_grad(rho_up_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							p2_temp_3d = cdfbvn_grad(rho_low_g1,rho_up_g2,corr_g1g2); @Returns column vector@
							p2_temp_4d = cdfbvn_grad(rho_low_g1,rho_low_g2,corr_g1g2); @Returns column vector@
							
							p2_temp_11d = rho_up_g1d|rho_up_g2d|0;
							p2_temp_22d = rho_up_g1d|rho_low_g2d|0;
							p2_temp_33d = rho_low_g1d|rho_up_g2d|0;
							p2_temp_44d = rho_low_g1d|rho_low_g2d|0;
							
							p2_dd = p2_dd + (1/nvar_mear_ordl)*(1/p2_temp)*((p2_temp_1d'*p2_temp_11d) - (p2_temp_2d'*p2_temp_22d) - (p2_temp_3d'*p2_temp_33d) + (p2_temp_4d'*p2_temp_44d));
			   
							clear rho_low_g1,rho_low_g2,rho_up_g1,rho_up_g2,corr_g1g2,p2_temp; 
							clear rho_low_g1d, rho_low_g2d, rho_up_g1d, rho_up_g2d, p2_temp_1d, p2_temp_2d, p2_temp_3d, p2_temp_4d, p2_temp_11d, p2_temp_22d, p2_temp_33d, p2_temp_44d; 
						endfor;
					endfor;
				else; @i.e. if nvar_mear_ordl == 0 or nvar_mear_ordl == 1@
					p2_dd = 0;
				endif; @End of calculation of p2_dd - considering the pairs of the ordinals for the 3rd and last case@
		
				if(nvar_mear_ordl > 0); @Calculation for p3@
					lower_threshold_append = {}; upper_threshold_append = {}; 
					lower_threshold_append = lower_threshold_append | lower_threshold_matrix[j,.]'; @Column vector@
					upper_threshold_append = upper_threshold_append | upper_threshold_matrix[j,.]'; @Column vector@
					lower_threshold_append = lower_threshold_append |  0*zeros(rows(nch),1); @Column vector@
					upper_threshold_append = upper_threshold_append |  0*zeros(rows(nch),1);
		   
					p3_dd = 0;
					for g3(1,nvar_mear_ordl,1);
						S = zeros((rows(nch)+1),nvar_mear_ordl+rows(nch));	@Creating the S(g) matrix: I(number of alternatives) x (G+I-1) matrix@
						S[1,g3] = 1; @Put an 1 in the first row and g3th column@
						S[2:rows(S),nvar_mear_ordl+1:nvar_mear_ordl+rows(nch)] = eye(rows(nch)); @Put an identity matrix in the last(I-1) rows and (I-1) columns@
		   
						rho_low_g3 = S*lower_threshold_append; @(1 + (nc - 1)) x 1 vector - First value correspond to the lower threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
						rho_up_g3  = S*upper_threshold_append; @(1 + (nc-1)) x 1 vector - First value correspond to the upper threshold of ordinal indicator, rest (I-1) to (I-1) choice alternatives, that are not chosen@
		   
						mean_ordl_nc  = S*mean_two_final; @Again an (1 + (nc-1)) x 1 vector, - First 1 correspond to ordinal indicator, the rest to non-chosen choice alternatives@
						var_ordl_nc   = S*err_two_final*S'; @An I(nc) x I(nc) matrix@
			
						st_err_ordl_nc = sqrt(diag(var_ordl_nc)); @Standard error of the conditional distribution@
						mean_low_final = (rho_low_g3 - mean_ordl_nc)./st_err_ordl_nc;
						mean_up_final  = (rho_up_g3 - mean_ordl_nc)./st_err_ordl_nc;
						corr_ordl_nc   = corrvc(var_ordl_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
						corr_ordl_nc   = diagrv(corr_ordl_nc,ones((rows(nch)+1),1));
						
						mean_ordl_nc_d = S*mean_two_final_d; @The derivatives of the errors are zero@
						mean_low_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
						mean_up_final_d = (-mean_ordl_nc_d)./st_err_ordl_nc;
			
						if((rows(nch)+1) == 2);
							p3_temp = cdfBvn(mean_up_final[1], mean_up_final[2],corr_ordl_nc[1,2])- cdfBvn(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]);
							
							p3_temp_low_d = cdfbvn_grad(mean_low_final[1], mean_low_final[2], corr_ordl_nc[1,2]); @Returns column vetor@
							p3_temp_up_d = cdfbvn_grad(mean_up_final[1], mean_up_final[2], corr_ordl_nc[1,2]);	@Returns column vector@
							p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_up_d[1:2]'*mean_up_final_d - p3_temp_low_d[1:2]'*mean_low_final_d);
						else; @pcdfmvna() can only be used when rows(nch)+1 is greater than 2@
							{ p3_temp1,p3_temp_d1, sq } = pdfmvna(mean_up_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
							if (rho_low_g3[1] .== negative_infinity);
								p3_temp = p3_temp1;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d); @The derivative of the mean_low_final_d is ignored@
							else;
								{ p3_temp2,p3_temp_d2, sq } = pdfmvna(mean_low_final',corr_ordl_nc,seedn); @p3_temp_d is a row vector@
								p3_temp = p3_temp1 - p3_temp2;
								p3_dd = p3_dd + (1/nvar_mear_ordl)*(1/p3_temp)*(p3_temp_d1[1:(rows(nch)+1)]*mean_up_final_d - p3_temp_d2[1:(rows(nch)+1)]*mean_low_final_d); @The derivative of the mean_low_final_d is ignored@
							endif;
						endif;

						
						clear p3_temp, p3_temp1, p3_temp2, p3_temp_d1, p3_temp_d2, S, rho_low_g3, rho_up_g3, mean_ordl_nc, var_ordl_nc, st_err_ordl_nc, mean_low_final, mean_up_final, corr_ordl_nc;
						clear mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, p3_temp_low_d, p3_temp_up_d, p3_temp_d;
					endfor; @End of calculation for p3_dd in the presence of ordinal indicators@
				else; @If there are no ordinal indicators@
					mean_nc  = mean_two_final; 
					var_nc   = err_two_final; 
		
					st_err_nc = sqrt(diag(var_nc)); @Standard error of the conditional distribution@
					mean_nc_final = (- mean_nc)./st_err_nc;
					corr_nc   = corrvc(var_nc); @Calculates the correlation matrix of the variance covariance matrix var_gu@
					corr_nc   = diagrv(corr_nc,ones(rows(nch),1));
					
					mean_nc_d = mean_two_final_d;
					mean_nc_final_d = (-mean_nc_d)./st_err_nc; @Derivative of the errors are zero@
			
					if(rows(nch) == 1);
						p3 = cdfn(mean_nc_final);
						p3_d = pdfn(mean_nc_final);
						p3_dd = (1/p3)*(p3_d.*mean_nc_final_d);
					elseif(rows(nch)==2);
						p3 = cdfBvn(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_d = cdfbvn_grad(mean_nc_final[1], mean_nc_final[2], corr_nc[1,2]);
						p3_dd = (1/p3)*(p3_d[1:2]'*mean_nc_final_d); @Returns column vector@
					else;
						{ p3,p3_d, sq } = pdfmvna(mean_nc_final',corr_nc,seedn);	@p3_d is a row vector@
						p3_dd = (1/p3)*(p3_d[1:rows(nch)]*mean_nc_final_d);
					endif;
				endif; @End of calccualtion for p3_dd for the last case@
				clear k, ch, nch, mear_ch, mean_one_obs, mean_one, err_one_var,mear_nch, mean_two, err_two_var, cov_one_two, mean_two_final, err_two_final, mean_nc, var_nc, st_err_nc, mean_nc_final, corr_nc; 			
				clear mean_one_d, mean_one_obs_d, mean_two_d, mean_two_final_d, mean_ordl_nc_d, mean_low_final_d, mean_up_final_d, mean_nc_d, mean_nc_final_d;
			endif; @End of check for how many alternatives have been consumed@
		
			gg = jac_grad[j] + p1_dd + p2_dd + p3_dd; @Summing the gradients for a particular individual@
			gg_temp = gg_temp|gg; @concatenating for each individual@
			print "j: " j "gg_temp[j,.]: " gg_temp[j,.];
			seedn = sq;
			j = j+1;
		endo; @End of looping for individual@
		
		post_obs = ones(nobs,1);
		gg_temp = gg_temp .* post_obs;
		gamma_score = gamma_score~gg_temp;
		clear xgam_grad, u2_grad, u_grad, f_grad;
	endif; @End of check whether the parameter is active@
 endfor; @End of loop through the alpha gradient@	
		
 gradient = {};
 if(nvar_mear_ordl == 0);
	gradient = gradient~alpha_z_score~alpha_corr_score~delta_coeff_score~dmatrix_score~Psi_score~beta_score~lambda_score~alpha_score~gamma_score~covn_score;
 else; @Add gradients for the threshold parameters@
	gradient = gradient~alpha_z_score~alpha_corr_score~delta_coeff_score~dmatrix_score~Psi_score~lower_threshold_score~upper_threshold_score~beta_score~lambda_score~alpha_score~gamma_score~covn_score;
 endif;
 gradient_store1 = gradient;
 retp(gradient);
 endp;





// Procedure to compute the pdf of a multivariate normal
// x is vector and s is the covariance matrix
proc pdfmvn(x,u,s);
 local d,p,p1,p2;
 d = rows(x);
 p1 = exp(-0.5*((x-u)'*inv(s)*(x-u)));
 p2 = ((2*pi)^(d/2))*sqrt(det(s));
 p = p1/p2;
 retp(p);
endp;

proc(1)=pdfgmean(x,mu,s);
    local d,p,p1,p2,p3,grad1,grad,store,ie;
	 d = rows(x);
	 p1 = exp(-0.5*((x-mu)'*inv(s)*(x-mu)));
	 p2 = ((2*pi)^(d/2))*sqrt(det(s));
	 p3 = inv(s);
	 p = p1/p2;
	 store = zeros(d,1);
	 for ie(1,d,1);
		  grad = -1*((x-mu).*p3[.,ie]); /*It should be positive, there should not be any negative sign*/
		  grad1 = sumc(grad);
		  grad1 = p*grad1;
		  store[ie] = grad1;
	 endfor;
	 retp(store);
endp;

/*Gradient with respect to each element of the variance covariance matrix*/
proc(1)=pdfgcov(x,mu,r);
	local d,p1,p2,p,p4,out,i,j,diff_matrix,part11,part12,part13,part1,s,ncholerr,diff_matrix1;
    local part21,part22,part23,part24,part2,gradient;
    d = rows(x);
    s = xpnd(r);
	ncholerr = rows(r);
    p1 = exp(-0.5*((x-mu)'*inv(s)*(x-mu)));
    p2 = ((2*pi)^(d/2));
    p = p1/p2;
    p4 = inv(s);
    out = {};
    for i(1,ncholerr,1);
        
            diff_matrix1 = zeros(ncholerr,1);
			diff_matrix1[i,1]= 1;
			diff_matrix = xpnd(diff_matrix1);
            
            part11 = p4*diff_matrix;
            part12 = diag(part11);
            part13 = sumc(part12);
            part1 = -0.5*part13;
            part1 = part1/sqrt(det(s));
            
            part21 = (((p4*(x-mu))*(x-mu)')*p4);
            part22 = part21*diff_matrix;
            part23 = diag(part22);
            part24 = sumc(part23);
			/**The following code block should work as well**/
			/*part21 = p4*diff_matrix*p4;
			part22 = (x-mu)'*part21;
			part23 = part22 * (x-mu);
			part24 = part23;*/
            part2 = 0.5*part24;
            part2 = part2/sqrt(det(s));
            
            gradient = p*(part1 + part2);
            out = out | gradient;
        
    endfor;
    retp(out);
endp;

proc(1)=cdfbvn_grad(a,b,corr);
    local d_a,d_b,d_corr;
    d_a     = pdfn(a) .* cdfn((b- corr .* a) ./ sqrt(1-corr .* corr) ); //formulae found
    d_b     = pdfn(b) .* cdfn((a- corr .* b) ./ sqrt(1-corr .* corr) ); //formuale found
    d_corr  = (exp(-0.5*((a^2 + b^2 - 2*corr .* a .* b   ) ./ (1-corr .* corr) ))) ./ ((2*pi) * sqrt(1-corr .* corr)); //The bivariate normal pdf - why is that?
    retp(d_a|d_b|d_corr);
endp;
